<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI 수학</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#1a1714">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#f5f0ea;--fg:#1a1714;--card:#ebe5dc;--card-h:#e2dbd1;--muted:#78726a;
  --accent:#c8b9a6;--border:#d8d0c4;--red:#b44133;--green:#5a7a5a;--blue:#4a6b8a;
  --radius:0.5rem;--sans:'Noto Sans KR',system-ui,sans-serif;--mono:'JetBrains Mono',monospace;
}
*{margin:0;padding:0;box-sizing:border-box;}
html{scroll-behavior:smooth;}
body{font-family:var(--sans);background:var(--bg);color:var(--fg);line-height:1.75;-webkit-font-smoothing:antialiased;min-height:100vh;display:flex;flex-direction:column;}

/* ── NAV ── */
header{position:sticky;top:0;z-index:100;background:rgba(245,240,234,0.92);backdrop-filter:blur(16px);border-bottom:1px solid var(--border);}
nav{max-width:68rem;margin:0 auto;display:flex;align-items:center;gap:1.5rem;padding:0.75rem 1.5rem;overflow-x:auto;scrollbar-width:none;}
nav::-webkit-scrollbar{display:none;}
.logo{font-size:0.95rem;font-weight:600;letter-spacing:-0.02em;color:var(--fg);text-decoration:none;white-space:nowrap;flex-shrink:0;}
.nav-btn{font-family:var(--mono);font-size:0.68rem;letter-spacing:0.06em;padding:0.45rem 0.9rem;border:1px solid var(--border);border-radius:9999px;background:transparent;color:var(--muted);cursor:pointer;transition:all 0.2s;white-space:nowrap;flex-shrink:0;}
.nav-btn:hover{border-color:var(--muted);color:var(--fg);}
.nav-btn.active{background:var(--fg);color:var(--bg);border-color:var(--fg);}

/* ── LAYOUT ── */
main{max-width:68rem;margin:0 auto;padding:0 1.5rem;flex:1;width:100%;}
.view{display:none;padding:3rem 0 4rem;animation:fadeIn 0.3s ease;}
.view.active{display:block;}
@keyframes fadeIn{from{opacity:0;transform:translateY(8px);}to{opacity:1;transform:translateY(0);}}

/* ── TYPO ── */
.mono{font-family:var(--mono);font-size:0.62rem;text-transform:uppercase;letter-spacing:0.18em;color:var(--muted);}
h1{font-size:clamp(1.6rem,3.8vw,2.4rem);font-weight:600;letter-spacing:-0.03em;line-height:1.25;white-space:nowrap;}
h2{font-size:clamp(1.3rem,2.5vw,1.7rem);font-weight:600;letter-spacing:-0.02em;margin-bottom:0.3rem;}
h3{font-size:0.95rem;font-weight:600;margin-bottom:0.5rem;}
.desc{font-size:0.86rem;color:var(--muted);max-width:42rem;margin-bottom:2rem;line-height:1.85;}

/* ── CARD ── */
.card{background:var(--card);border-radius:var(--radius);padding:1.4rem;margin-bottom:1.2rem;}
.card p,.card li{font-size:0.84rem;color:var(--muted);line-height:1.85;}
.card-link{background:var(--card);border-radius:var(--radius);padding:1.4rem;cursor:pointer;transition:all 0.2s;border:1px solid transparent;position:relative;}
.card-link:hover{background:var(--card-h);border-color:var(--border);transform:translateY(-2px);box-shadow:0 2px 8px rgba(26,23,20,0.06);}
.card-link::after{content:'→';position:absolute;top:1.4rem;right:1.4rem;font-size:0.9rem;color:var(--muted);transition:transform 0.2s;}
.card-link:hover::after{transform:translateX(3px);color:var(--fg);}
.card-link h3{font-size:0.95rem;font-weight:600;margin-bottom:0.5rem;}
.card-link p{font-size:0.84rem;color:var(--muted);line-height:1.85;padding-right:1.5rem;}

/* ── MATH ── */
.math{background:var(--fg);color:var(--bg);border-radius:var(--radius);padding:1.2rem 1.5rem;font-family:var(--mono);font-size:0.8rem;line-height:2;overflow-x:auto;margin:1.2rem 0;white-space:pre-line;}
.mi{font-family:var(--mono);font-size:0.78em;background:var(--card);padding:0.1rem 0.3rem;border-radius:3px;}

/* ── BTN ── */
.btn{font-family:var(--mono);font-size:0.66rem;letter-spacing:0.07em;text-transform:uppercase;padding:0.5rem 1rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--card);color:var(--fg);cursor:pointer;transition:all 0.2s;user-select:none;}
.btn:hover{background:var(--card-h);}
.btn.pri{background:var(--fg);color:var(--bg);border-color:var(--fg);}
.btn.pri:hover{opacity:0.85;}
.btn:disabled{opacity:0.35;cursor:not-allowed;}
.btn-row{display:flex;gap:0.4rem;flex-wrap:wrap;margin:0.8rem 0;}

/* ── INFO ── */
.info{background:var(--card);border-left:3px solid var(--accent);padding:0.9rem 1.1rem;border-radius:0 var(--radius) var(--radius) 0;margin:1.4rem 0;font-size:0.84rem;color:var(--muted);line-height:1.85;}
.info strong{color:var(--fg);}
.status{font-family:var(--mono);font-size:0.72rem;color:var(--muted);margin:0.6rem 0;min-height:1.3rem;}

/* ── TAGS ── */
.tags{display:flex;flex-wrap:wrap;gap:0.35rem;margin-top:1rem;}
.tag{font-family:var(--mono);font-size:0.6rem;padding:0.22rem 0.55rem;background:var(--card);border-radius:9999px;color:var(--muted);}

/* ── TABS ── */
.tabs{display:flex;gap:0;border-bottom:1px solid var(--border);margin-bottom:1.4rem;}
.tab{font-family:var(--mono);font-size:0.66rem;letter-spacing:0.05em;padding:0.5rem 1rem;border:none;background:transparent;color:var(--muted);cursor:pointer;border-bottom:2px solid transparent;transition:all 0.2s;}
.tab:hover{color:var(--fg);}
.tab.on{color:var(--fg);border-bottom-color:var(--fg);}
.tpanel{display:none;}.tpanel.on{display:block;}

/* ── MATRIX ── */
.grid-wrap{display:flex;flex-wrap:wrap;gap:1.2rem;align-items:flex-start;justify-content:center;margin:1.5rem 0;}
.mat-label{font-family:var(--mono);font-size:0.6rem;text-transform:uppercase;letter-spacing:0.1em;color:var(--muted);margin-bottom:0.4rem;text-align:center;}
.mat{display:inline-grid;gap:2px;background:var(--border);border-radius:var(--radius);padding:2px;}
.mc{width:2.6rem;height:2.6rem;display:flex;align-items:center;justify-content:center;background:var(--card);font-family:var(--mono);font-size:0.78rem;font-weight:500;transition:all 0.25s;user-select:none;}
.mc.win{background:var(--accent);color:var(--fg);}.mc.win-active{background:var(--fg);color:var(--bg);font-weight:700;}.mc.res{background:var(--accent);font-weight:700;}.mc.done{background:var(--green);color:#fff;}
.op{font-size:1.4rem;color:var(--muted);display:flex;align-items:center;padding:0 0.2rem;font-weight:300;}

/* ── EDIT GRID ── */
.eg{display:inline-grid;gap:2px;background:var(--border);border-radius:var(--radius);padding:2px;}
.ec{width:2.6rem;height:2.6rem;display:flex;align-items:center;justify-content:center;background:var(--card);transition:background 0.2s;}
.ec:focus-within{background:#fff;outline:2px solid var(--fg);outline-offset:-2px;z-index:1;}
.ec input{width:100%;height:100%;border:none;background:transparent;text-align:center;font-family:var(--mono);font-size:0.85rem;font-weight:600;color:var(--fg);outline:none;padding:0;-moz-appearance:textfield;}
.ec input::-webkit-outer-spin-button,.ec input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0;}

/* ── BITMAP ── */
.bmp{display:inline-grid;gap:1px;background:var(--border);border-radius:var(--radius);padding:1px;cursor:crosshair;}
.bc{background:var(--bg);transition:background 0.08s;}
.bc.on{background:var(--fg);}.bc:hover{background:var(--accent);}.bc.on:hover{background:var(--muted);}

/* ── OVERLAP GRID ── */
.ovlap{display:inline-grid;gap:1px;background:var(--border);border-radius:var(--radius);padding:1px;}
.oc{transition:background 0.15s;}
.oc.both{background:var(--fg);}
.oc.match{background:var(--card);}
.oc.only-user{background:var(--red);opacity:0.7;}
.oc.only-ref{background:var(--blue);opacity:0.7;}

/* ── HAMMING BARS ── */
.hb{display:flex;align-items:center;gap:0.5rem;margin:0.3rem 0;}
.hb .dl{font-family:var(--mono);font-size:0.78rem;font-weight:600;width:1.3rem;text-align:center;}
.hb .tk{flex:1;height:1.2rem;background:var(--card);border-radius:9999px;overflow:hidden;}
.hb .fl{height:100%;border-radius:9999px;transition:width 0.5s cubic-bezier(0.22,1,0.36,1);background:var(--fg);}
.hb .fl.best{background:var(--green);}
.hb .dv{font-family:var(--mono);font-size:0.65rem;color:var(--muted);width:5rem;text-align:right;}

/* ── CHIPS ── */
.chips{display:flex;flex-wrap:wrap;gap:0.35rem;margin:0.8rem 0;}
.chip{font-family:var(--mono);font-size:0.6rem;padding:0.3rem 0.65rem;border:1px solid var(--border);border-radius:9999px;background:transparent;color:var(--muted);cursor:pointer;transition:all 0.2s;}
.chip:hover{border-color:var(--muted);}.chip.on{background:var(--fg);color:var(--bg);border-color:var(--fg);}

/* ── UPLOAD ── */
.upz{border:2px dashed var(--border);border-radius:var(--radius);padding:1.5rem;text-align:center;cursor:pointer;transition:all 0.2s;margin:0.8rem 0;}
.upz:hover,.upz.dg{border-color:var(--fg);background:var(--card);}
.upz p{font-size:0.8rem;color:var(--muted);}.upz input{display:none;}

/* ── CANVAS ── */
.cv{image-rendering:pixelated;border-radius:var(--radius);border:2px solid var(--border);}

/* ── NORM ── */
.ns{-webkit-appearance:none;width:100%;max-width:26rem;height:6px;background:var(--border);border-radius:9999px;outline:none;}
.ns::-webkit-slider-thumb{-webkit-appearance:none;width:1.3rem;height:1.3rem;background:var(--fg);border-radius:50%;cursor:pointer;}
.nout{display:flex;justify-content:center;gap:2rem;margin-top:1rem;flex-wrap:wrap;}
.nb{text-align:center;}.nb .v{font-family:var(--mono);font-size:1.6rem;font-weight:600;}
.nb .l{font-family:var(--mono);font-size:0.55rem;letter-spacing:0.1em;text-transform:uppercase;color:var(--muted);margin-top:0.15rem;}
.sw{width:3rem;height:3rem;border-radius:var(--radius);margin:0.3rem auto;border:1px solid var(--border);}

/* ── COMPARE ── */
.cmp{display:grid;grid-template-columns:1fr 1fr;border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;margin:1.4rem 0;}
.cmp-c{padding:1.3rem;}.cmp-c:first-child{border-right:1px solid var(--border);}
.cmp-c h4{font-size:0.86rem;font-weight:600;margin-bottom:0.6rem;}
.cr{font-size:0.8rem;color:var(--muted);line-height:1.7;margin-bottom:0.4rem;}
.cr strong{color:var(--fg);}

/* ── FOOTER ── */
footer{border-top:1px solid var(--border);margin-top:auto;}
footer .inner{max-width:68rem;margin:0 auto;padding:1.1rem 1.5rem;display:flex;justify-content:space-between;font-family:var(--mono);font-size:0.65rem;color:var(--muted);}

@media(max-width:640px){
  h1{font-size:1.4rem;white-space:normal;}
  .cmp{grid-template-columns:1fr;}.cmp-c:first-child{border-right:none;border-bottom:1px solid var(--border);}
  .mc,.ec{width:2.1rem;height:2.1rem;font-size:0.68rem;}
  nav{gap:0.5rem;}
  #v-perceptron>div{grid-template-columns:1fr !important;}
}
</style>
</head>
<body>

<header>
  <nav>
    <a href="#" class="logo" onclick="go('home');return false;">AI 수학</a>
    <button class="nav-btn active" data-v="home">홈</button>
    <button class="nav-btn" data-v="hamming">해밍 거리</button>
    <button class="nav-btn" data-v="conv">합성곱</button>
    <button class="nav-btn" data-v="filter">필터 실습</button>
    <button class="nav-btn" data-v="pool">풀링 · 정규화</button>
    <button class="nav-btn" data-v="perceptron">퍼셉트론</button>
    <button class="nav-btn" data-v="text">텍스트 데이터</button>
    <button class="nav-btn" data-v="detect">객체 탐지</button>
  </nav>
</header>

<main>

<!-- ═══════════ HOME ═══════════ -->
<div class="view active" id="v-home">
  <p class="mono" style="margin-bottom:0.5rem;">인공지능 수학</p>
  <h1>인공지능의 수학적 원리</h1>
  <p class="desc" style="margin-top:0.8rem;">
    인공지능의 핵심 개념들을 수학적으로 이해하고,
    직접 조작하며 학습할 수 있습니다.
  </p>

  <div style="margin-top:2.5rem;">
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(14rem,1fr));gap:1rem;">
      <div class="card-link" onclick="go('hamming')">
        <h3>해밍 거리</h3>
        <p>두 이진 데이터 사이의 차이를 XOR 연산으로 측정합니다. 이미지를 행렬로 변환한 뒤 유사도를 비교하는 기본적인 분류 방법입니다.</p>
      </div>
      <div class="card-link" onclick="go('conv')">
        <h3>합성곱 연산</h3>
        <p>CNN의 핵심 연산인 합성곱(아다마르 곱)의 원리를 이해합니다. 필터가 이미지 위를 이동하며 특징을 추출하는 과정을 다룹니다.</p>
      </div>
      <div class="card-link" onclick="go('filter')">
        <h3>필터 실습</h3>
        <p>직접 이미지를 업로드하고, 다양한 커널(세로선, 가로선, 블러, 윤곽선 등)을 적용하여 결과를 확인합니다.</p>
      </div>
      <div class="card-link" onclick="go('pool')">
        <h3>풀링과 정규화</h3>
        <p>맥스 풀링으로 데이터를 압축하는 과정과, 학습 효율을 위한 데이터 정규화를 체험합니다.</p>
      </div>
      <div class="card-link" onclick="go('perceptron')">
        <h3>퍼셉트론</h3>
        <p>신경망의 기본 단위인 퍼셉트론의 작동 원리를 시각화합니다. 입력, 가중치, 활성화 함수의 관계를 직접 조작하며 확인합니다.</p>
      </div>
      <div class="card-link" onclick="go('text')">
        <h3>텍스트 데이터</h3>
        <p>자연어를 수치 벡터로 변환하는 과정을 학습합니다. 원-핫 인코딩과 빈도수 벡터(BoW)를 직접 체험합니다.</p>
      </div>
      <div class="card-link" onclick="go('detect')">
        <h3>객체 탐지</h3>
        <p>학습된 AI 모델이 이미지에서 물체를 인식하는 과정을 직접 체험합니다. 이미지를 업로드하면 실시간으로 객체를 탐지합니다.</p>
      </div>
    </div>
  </div>
</div>

<!-- ═══════════ HAMMING ═══════════ -->
<div class="view" id="v-hamming">
  <p class="mono" style="margin-bottom:0.4rem;">해밍 거리</p>
  <h2>XOR 연산과 유사도 측정</h2>
  <p class="desc">
    같은 길이의 두 이진 문자열에서 대응하는 위치의 값이 서로 다른 개수를 해밍 거리라 합니다.
    XOR 연산 결과에서 1의 개수를 세면 됩니다.
  </p>

  <div class="card">
    <h3>왜 해밍 거리를 배울까?</h3>
    <p>컴퓨터는 이미지, 텍스트, 소리 등 모든 데이터를 0과 1로 저장합니다.
      두 데이터가 얼마나 비슷한지를 판단하려면, 같은 위치에서 값이 다른 개수를 세면 됩니다.
      이것이 해밍 거리의 핵심 아이디어이며, 데이터 분류의 가장 기본적인 수학적 도구입니다.</p>
    <p style="margin-top:0.5rem;">해밍 거리는 통신 분야에서 오류 검출 및 정정에 사용되며,
      생물정보학에서 DNA 서열 비교, 정보 검색에서 유사 문서 탐색,
      그리고 QR 코드의 오류 복원 등 다양한 분야에서 활용됩니다.</p>
  </div>

  <div class="tabs">
    <button class="tab on" onclick="htab(0,this)">XOR 원리</button>
    <button class="tab" onclick="htab(1,this)">비트맵 실습</button>
  </div>

  <!-- TAB 0: XOR -->
  <div class="tpanel on" id="ht0">
    <div class="card">
      <h3>XOR 연산 진리표</h3>
      <p>두 비트가 서로 다를 때 1, 같을 때 0을 출력합니다.</p>
      <div class="math">0 ⊕ 0 = 0   (같음)
0 ⊕ 1 = 1   (다름)
1 ⊕ 0 = 1   (다름)
1 ⊕ 1 = 0   (같음)

해밍 거리 d(A,B) = Σ (Aᵢ ⊕ Bᵢ)</div>
    </div>

    <div class="card">
      <h3>직접 해보기 — 비트를 클릭하여 값을 바꿔보세요</h3>
      <p style="margin-bottom:0.8rem;">각 비트를 클릭하면 0과 1이 토글됩니다. XOR 결과와 해밍 거리가 실시간으로 계산됩니다.</p>
      <div id="hd-box" style="display:flex;flex-direction:column;gap:0.5rem;align-items:center;"></div>
      <div id="hd-res" class="status" style="text-align:center;font-size:0.85rem;font-weight:600;"></div>
    </div>

    <div class="info">
      <strong>대칭차집합과의 관계:</strong>
      XOR 연산은 대칭차집합 <span class="mi">(A∪B)−(A∩B)</span>과 동일한 결과를 보입니다.
      이 연산에 최소 2단계가 필요하므로, 다층 퍼셉트론에서 은닉층이 2개 이상 필요한 이유와 연결됩니다.
    </div>
  </div>

  <!-- TAB 1: BITMAP -->
  <div class="tpanel" id="ht1">
    <p class="desc" style="margin-bottom:1rem;">
      격자에 숫자를 직접 그려보세요. 클릭/드래그로 흑백을 토글합니다.
      참조 데이터(0~9)와의 해밍 거리를 계산하여 가장 유사한 숫자를 자동 분류합니다.
    </p>

    <div style="display:flex;gap:0.3rem;margin-bottom:1rem;">
      <button class="btn bsz active" onclick="setSz(6,this)">6×6</button>
      <button class="btn bsz" onclick="setSz(8,this)">8×8</button>
      <button class="btn bsz" onclick="setSz(12,this)">12×12</button>
    </div>

    <div style="display:flex;flex-wrap:wrap;gap:2rem;align-items:flex-start;">
      <div>
        <p class="mat-label">나만의 숫자 그리기</p>
        <div id="ubmp" class="bmp"></div>
        <div class="btn-row">
          <button class="btn" onclick="clrBmp()">초기화</button>
          <button class="btn pri" onclick="calcH()">해밍 거리 계산</button>
        </div>
        <p style="font-size:0.72rem;color:var(--muted);margin-top:0.3rem;">참조 숫자 미리보기</p>
        <div class="btn-row" id="rbtn"></div>
        <div id="refpreview" style="margin-top:0.5rem;"></div>
      </div>
      <div style="flex:1;min-width:14rem;">
        <p class="mat-label">분류 결과</p>
        <div id="hbars"><p style="font-size:0.8rem;color:var(--muted);">숫자를 그린 후 계산 버튼을 누르세요.</p></div>
        <div id="hbest" class="status" style="font-weight:600;"></div>
        <div id="hoverlap" style="margin-top:1rem;"></div>
      </div>
    </div>

    <div class="info" style="margin-top:1.5rem;">
      <strong>한계점:</strong> 해밍 거리는 위치 이동, 크기 변화, 획의 굵기 차이에 취약합니다.
      이를 개선하기 위해 전처리, 데이터 증강, 그리고 CNN 같은 딥러닝이 사용됩니다.
    </div>
  </div>
</div>

<!-- ═══════════ CONV ═══════════ -->
<div class="view" id="v-conv">
  <p class="mono" style="margin-bottom:0.4rem;">합성곱 연산</p>
  <h2>CNN의 핵심 — 아다마르 곱</h2>
  <p class="desc">
    같은 크기의 두 행렬에서 동일 위치의 성분끼리 곱한 후 모두 더하는 연산입니다.
    필터가 이미지 위를 한 칸씩 이동하며 이 연산을 반복하여 특징 맵을 생성합니다.
  </p>

  <div class="card">
    <h3>합성곱이 왜 중요한가?</h3>
    <p>기존 방식(해밍 거리)은 픽셀 위치를 하나하나 비교하기 때문에, 같은 숫자라도 위치가 조금만 달라지면 전혀 다른 것으로 판단합니다. 합성곱은 이미지의 부분적 패턴(가로선, 세로선, 모서리 등)을 찾아내기 때문에 위치 변화에 강하고, 이것이 CNN이 이미지 인식에 뛰어난 핵심 이유입니다.</p>
    <p style="margin-top:0.5rem;">합성곱 신경망(CNN)은 1989년 얀 르쿤(Yann LeCun)이 손글씨 숫자 인식을 위해 제안한 이래, 의료 영상 진단, 자율주행 차량의 물체 인식, 얼굴 인식, 위성 사진 분석 등 시각 정보를 다루는 거의 모든 AI 분야에서 사용됩니다.</p>
  </div>

  <div class="cmp" style="margin-bottom:2rem;">
    <div class="cmp-c">
      <h4>인간의 눈</h4>
      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Schematic_diagram_of_the_human_eye_en.svg/400px-Schematic_diagram_of_the_human_eye_en.svg.png" alt="인간 눈의 구조" style="width:100%;max-width:220px;border-radius:var(--radius);margin:0.6rem 0;opacity:0.85;">
      <div class="cr"><strong>망막</strong> — 빛을 전기 신호로 변환</div>
      <div class="cr"><strong>시각 피질</strong> — 가로선, 세로선, 색상 등 기초 특징 감지</div>
      <div class="cr"><strong>측두엽</strong> — 형태를 조합하여 사물 인식</div>
    </div>
    <div class="cmp-c">
      <h4>CNN 인공신경망</h4>
      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Typical_cnn.png/400px-Typical_cnn.png" alt="CNN 구조" style="width:100%;max-width:220px;border-radius:var(--radius);margin:0.6rem 0;opacity:0.85;">
      <div class="cr"><strong>입력층</strong> — 이미지를 픽셀(숫자) 데이터로 변환</div>
      <div class="cr"><strong>합성곱층</strong> — 필터로 외곽선, 질감 등 특징 추출</div>
      <div class="cr"><strong>완전연결층</strong> — 추출된 특징을 종합하여 최종 분류</div>
    </div>
  </div>

  <div class="tabs">
    <button class="tab on" onclick="ctab(0,this)">직접 계산</button>
    <button class="tab" onclick="ctab(1,this)">단계별 시각화</button>
  </div>

  <!-- TAB 0: manual -->
  <div class="tpanel on" id="ct0">
    <div class="card">
      <h3>합성곱 결과를 직접 계산해보세요</h3>
      <p>입력 행렬과 커널의 값을 편집할 수 있습니다. 출력에 답을 입력한 뒤 정답을 확인하세요.</p>
    </div>

    <div class="grid-wrap">
      <div style="text-align:center;"><p class="mat-label">입력 (4×4) — 편집 가능</p><div class="eg" id="mi" style="grid-template-columns:repeat(4,1fr);"></div></div>
      <div class="op">*</div>
      <div style="text-align:center;"><p class="mat-label">커널 (3×3) — 편집 가능</p><div class="eg" id="mk" style="grid-template-columns:repeat(3,1fr);"></div></div>
      <div class="op">=</div>
      <div style="text-align:center;"><p class="mat-label">출력 (2×2) — 답 입력</p><div class="eg" id="mo" style="grid-template-columns:repeat(2,1fr);"></div></div>
    </div>
    <div class="btn-row" style="justify-content:center;">
      <button class="btn pri" onclick="chkMan()">정답 확인</button>
      <button class="btn" onclick="newMan()">새 문제</button>
    </div>
    <div id="mres" class="info" style="text-align:center;display:none;"></div>
    <div id="msol" style="display:none;margin-top:0.8rem;"></div>
  </div>

  <!-- TAB 1: auto viz -->
  <div class="tpanel" id="ct1">
    <div class="card">
      <h3>5×5 입력에 3×3 필터를 적용하는 과정</h3>
      <p>각 단계마다 어떤 성분이 곱해지고 합산되어 출력값이 되는지 확인하세요.</p>
    </div>

    <div class="grid-wrap">
      <div style="text-align:center;"><p class="mat-label">입력 (5×5)</p><div class="mat" id="ai" style="grid-template-columns:repeat(5,1fr);"></div></div>
      <div class="op">×</div>
      <div style="text-align:center;"><p class="mat-label">필터 (3×3)</p><div class="mat" id="ak" style="grid-template-columns:repeat(3,1fr);"></div></div>
      <div class="op">=</div>
      <div style="text-align:center;"><p class="mat-label">특징 맵 (3×3)</p><div class="mat" id="ao" style="grid-template-columns:repeat(3,1fr);"></div></div>
    </div>
    <div class="btn-row" style="justify-content:center;">
      <button class="btn" onclick="aReset()">리셋</button>
      <button class="btn" onclick="aStep()">한 단계</button>
      <button class="btn pri" onclick="aAuto()">자동 재생</button>
    </div>
    <div id="ast" class="status" style="text-align:center;"></div>
    <div id="acalc" class="info" style="text-align:center;">시작 버튼을 눌러 연산 과정을 확인하세요.</div>
  </div>

  <div class="math" style="margin-top:2rem;">Y = Σᵢ Σⱼ (Kᵢⱼ × Xᵢⱼ)

K: 필터(커널)  X: 입력의 일부  Y: 출력값
벡터로 펼치면 내적과 동일 — Y가 클수록 해당 영역이 필터 패턴과 유사</div>
</div>

<!-- ═══════════ FILTER ═══════════ -->
<div class="view" id="v-filter">
  <p class="mono" style="margin-bottom:0.4rem;">이미지 필터 실습</p>
  <h2>커널을 적용하여 특징 추출하기</h2>
  <p class="desc">
    이미지에 다양한 3×3 커널을 적용하여 결과를 확인하세요.
    직접 이미지를 업로드하거나, 커널 값을 편집하여 커스텀 필터를 만들 수 있습니다.
  </p>

  <div class="card">
    <h3>필터는 무엇을 하는가?</h3>
    <p>스마트폰 카메라 앱에서 사진을 선명하게 만들거나 흐리게 만드는 기능을 사용해본 적이 있을 것입니다.
      이것이 바로 커널(필터)을 이미지에 적용하는 합성곱 연산입니다.
      커널의 숫자 배치에 따라 세로선만 강조하거나, 가로선만 추출하거나, 전체를 흐리게 만들 수 있습니다.</p>
    <p style="margin-top:0.5rem;">CNN에서는 이러한 커널 값을 사람이 직접 정하지 않고, 학습 과정에서 AI가 스스로 최적의 값을 찾아냅니다.
      수천 장의 고양이 사진을 보여주면, 고양이의 귀 모양, 눈의 형태, 수염 패턴 등을 검출하는 필터가 자동으로 만들어집니다.</p>
  </div>

  <div class="upz" id="upz">
    <p style="font-weight:500;color:var(--fg);margin-bottom:0.2rem;">이미지를 드래그하거나 클릭하여 업로드하세요</p>
    <p style="font-size:0.7rem;margin-top:0.15rem;">jpg, png 등 이미지 파일을 지원합니다</p>
    <input type="file" id="fup" accept="image/*">
  </div>
  <div id="up-status" class="status"></div>
  <div class="btn-row">
    <button class="btn" onclick="createDefImg();applyF();document.getElementById('up-status').textContent='기본 도형 이미지가 적용되었습니다.';">기본 이미지 사용</button>
  </div>

  <div class="chips" id="fc"></div>

  <div class="card" style="text-align:center;">
    <p class="mono" style="margin-bottom:0.4rem;">적용 커널 — 값을 편집할 수 있습니다</p>
    <div class="eg" id="fk" style="grid-template-columns:repeat(3,1fr);display:inline-grid;"></div>
    <p id="fd" style="font-size:0.78rem;color:var(--muted);margin-top:0.6rem;max-width:30rem;margin-left:auto;margin-right:auto;"></p>
    <div class="btn-row" style="justify-content:center;margin-top:0.5rem;">
      <button class="btn pri" onclick="applyCustom()">커스텀 커널 적용</button>
    </div>
  </div>

  <div style="display:flex;flex-wrap:wrap;gap:1.5rem;justify-content:center;margin:1.5rem 0;">
    <div style="text-align:center;"><p class="mono" style="margin-bottom:0.3rem;">입력</p><canvas id="fin" class="cv" width="240" height="240"></canvas></div>
    <div style="display:flex;align-items:center;color:var(--muted);">→</div>
    <div style="text-align:center;"><p class="mono" style="margin-bottom:0.3rem;">출력 (필터 적용 후)</p><canvas id="fout" class="cv" width="240" height="240"></canvas></div>
  </div>
</div>

<!-- ═══════════ POOL + NORM ═══════════ -->
<div class="view" id="v-pool">
  <p class="mono" style="margin-bottom:0.4rem;">데이터 처리</p>
  <h2>풀링과 정규화</h2>
  <p class="desc">
    풀링은 이미지 크기를 줄이면서 핵심 정보를 보존하고,
    정규화는 학습 효율을 높이기 위해 값의 범위를 조정합니다.
  </p>

  <div class="card">
    <h3>왜 데이터를 줄이고 변환해야 할까?</h3>
    <p>스마트폰으로 찍은 사진 한 장은 보통 1,200만 개 이상의 픽셀로 이루어져 있습니다.
      이 모든 픽셀을 그대로 처리하면 연산량이 폭발적으로 늘어납니다.
      풀링은 이미지의 핵심 특징은 유지하면서 크기를 줄이는 기법으로, CNN의 각 합성곱층 뒤에 배치되어
      연산 효율을 높이고, 작은 위치 변화에 흔들리지 않는 안정적인 인식을 가능하게 합니다.</p>
    <p style="margin-top:0.5rem;">정규화는 서로 다른 범위의 데이터를 일정한 범위로 맞추는 과정입니다.
      키(cm)와 몸무게(kg)처럼 단위가 다른 데이터를 함께 학습시키려면 같은 스케일로 변환해야
      특정 값이 학습을 지배하는 것을 방지할 수 있습니다.</p>
  </div>

  <div class="tabs">
    <button class="tab on" onclick="ptab(0,this)">맥스 풀링</button>
    <button class="tab" onclick="ptab(1,this)">정규화</button>
  </div>

  <!-- TAB 0: pooling -->
  <div class="tpanel on" id="pt0">
    <div class="card">
      <h3>맥스 풀링 (Max Pooling)</h3>
      <p>4×4 입력에서 2×2씩 묶어 최대값만 선택하여 2×2로 압축합니다.
        입력값을 직접 편집하여 다양한 경우를 실험해보세요.</p>
    </div>

    <div class="grid-wrap">
      <div style="text-align:center;"><p class="mat-label">입력 (4×4) — 편집 가능</p><div class="eg" id="pi" style="grid-template-columns:repeat(4,1fr);"></div></div>
      <div class="op">→</div>
      <div style="text-align:center;"><p class="mat-label">출력 (2×2)</p><div class="mat" id="po" style="grid-template-columns:repeat(2,1fr);"></div></div>
    </div>
    <div class="btn-row" style="justify-content:center;">
      <button class="btn" onclick="pRst()">리셋</button>
      <button class="btn" onclick="pStp()">한 단계</button>
      <button class="btn pri" onclick="pAut()">자동 실행</button>
    </div>
    <div id="pst" class="status" style="text-align:center;"></div>
    <div class="info">
      <strong>효과:</strong> 이미지 크기는 줄지만 주요 특징은 유지됩니다.
      연산량을 줄이고, 물체 위치가 조금 바뀌어도 동일하게 인식하는 이동 불변성을 제공합니다.
    </div>
  </div>

  <!-- TAB 1: normalization -->
  <div class="tpanel" id="pt1">
    <div class="card">
      <h3>데이터 정규화 (Normalization)</h3>
      <p>이미지 픽셀은 0(검은색)~255(흰색)의 정수값을 가집니다.
        AI 모델 학습 시 0.0~1.0 사이의 실수로 변환합니다. 이는 행렬의 실수배 연산입니다.</p>
    </div>
    <div class="math" style="text-align:center;">X_normalized = X / 255</div>
    <div style="text-align:center;margin:2rem 0;">
      <p class="mono" style="margin-bottom:0.6rem;">슬라이더를 움직여 정규화를 체험하세요</p>
      <input type="range" class="ns" id="nsl" min="0" max="255" value="128">
      <div class="nout">
        <div class="nb"><div class="v" id="ni">128</div><div class="l">Integer (0–255)</div></div>
        <div class="nb"><div style="font-size:1.2rem;color:var(--muted);padding-top:0.3rem;">÷ 255 =</div></div>
        <div class="nb"><div class="v" id="nf">0.502</div><div class="l">Float (0.0–1.0)</div></div>
        <div class="nb"><div class="sw" id="nsw" style="background:rgb(128,128,128);"></div><div class="l">실제 색상</div></div>
      </div>
    </div>
    <div class="info">
      <strong>왜 필요한가:</strong> 정규화를 하지 않으면, 큰 값을 가진 특성이 학습을 지배하여
      모델이 편향되게 학습될 수 있습니다. 정규화는 경사 하강법의 수렴 속도를 높이고,
      수치 오버플로우를 방지하며, 다양한 특성을 공평하게 반영할 수 있게 합니다.
      이미지 외에도 음성, 센서 데이터 등 거의 모든 AI 입력 데이터에 정규화가 적용됩니다.
    </div>
  </div>
</div>

<!-- ═══════════ PERCEPTRON ═══════════ -->
<div class="view" id="v-perceptron">
  <p class="mono" style="margin-bottom:0.4rem;">퍼셉트론</p>
  <h2>신경망의 기본 단위</h2>
  <p class="desc">
    퍼셉트론은 입력값에 가중치를 곱하고 편향을 더한 뒤, 활성화 함수를 통과시켜 출력을 결정합니다.
    아래에서 입력, 가중치, 편향, 활성화 함수를 직접 조작해보세요.
  </p>

  <div class="card">
    <h3>퍼셉트론에서 딥러닝까지</h3>
    <p>1957년 프랭크 로젠블라트(Frank Rosenblatt)가 발명한 퍼셉트론은 인간 뇌의 뉴런을 수학적으로 모방한 것입니다.
      뉴런이 여러 신호를 받아 일정 임계값을 넘으면 활성화되는 것처럼, 퍼셉트론도 입력의 가중합이 임계값을 넘으면 1을 출력합니다.</p>
    <p style="margin-top:0.5rem;">하나의 퍼셉트론은 단순한 예/아니오 판단만 가능하지만(선형 분류),
      여러 퍼셉트론을 층으로 쌓으면 복잡한 패턴도 학습할 수 있습니다.
      이것이 바로 <strong>다층 퍼셉트론(MLP)</strong>이며, 현대 딥러닝의 기초입니다.</p>
    <p style="margin-top:0.5rem;">활성화 함수는 퍼셉트론에 비선형성을 부여하는 핵심 요소입니다.
      계단 함수는 가장 단순하지만, 미분이 불가능하여 학습에 제약이 있습니다.
      시그모이드는 부드러운 곡선으로 이 문제를 해결했고, ReLU는 학습 속도가 빨라 현대 딥러닝에서 가장 많이 사용됩니다.</p>
  </div>

  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;">
    <!-- LEFT: Controls -->
    <div>
      <div class="card">
        <h3>입력과 가중치</h3>
        <p style="margin-bottom:1rem;">슬라이더로 입력값을, 숫자 입력으로 가중치를 조절하세요.</p>
        <div id="pc-inputs"></div>
      </div>

      <div class="card">
        <h3>편향 (Bias)</h3>
        <div style="display:flex;align-items:center;gap:0.8rem;margin-top:0.5rem;">
          <span class="mono" style="width:1rem;">b</span>
          <input type="range" class="ns" id="pc-bias" min="-5" max="5" step="0.1" value="0" style="max-width:12rem;">
          <span id="pc-bias-val" style="font-family:var(--mono);font-size:0.8rem;min-width:3rem;text-align:right;">0.0</span>
        </div>
      </div>

      <div class="card">
        <h3>활성화 함수</h3>
        <div class="chips" id="pc-act-chips"></div>
        <div id="pc-threshold-wrap" style="margin-top:0.8rem;">
          <div style="display:flex;align-items:center;gap:0.8rem;">
            <span style="font-family:var(--mono);font-size:0.72rem;color:var(--muted);">임계값 (θ)</span>
            <input type="range" class="ns" id="pc-theta" min="-5" max="5" step="0.1" value="0" style="max-width:10rem;">
            <span id="pc-theta-val" style="font-family:var(--mono);font-size:0.8rem;min-width:3rem;text-align:right;">0.0</span>
          </div>
        </div>
      </div>

      <div class="card" id="pc-result-card">
        <h3>계산 과정</h3>
        <div id="pc-calc" style="font-family:var(--mono);font-size:0.78rem;line-height:2.2;color:var(--muted);"></div>
        <div style="margin-top:0.8rem;display:flex;align-items:baseline;gap:0.5rem;">
          <span style="font-family:var(--mono);font-size:0.72rem;color:var(--muted);">출력 y =</span>
          <span id="pc-output" style="font-family:var(--mono);font-size:1.6rem;font-weight:700;"></span>
        </div>
      </div>
    </div>

    <!-- RIGHT: Graph -->
    <div>
      <div class="card" style="height:100%;display:flex;flex-direction:column;">
        <h3>활성화 함수 그래프</h3>
        <p style="margin-bottom:0.5rem;">빨간 점은 현재 가중합 x와 출력 y의 위치입니다.</p>
        <canvas id="pc-graph" width="560" height="400" style="width:100%;aspect-ratio:560/400;border-radius:var(--radius);border:1px solid var(--border);background:#fff;"></canvas>
      </div>
    </div>
  </div>
</div>

<!-- ═══════════ TEXT DATA ═══════════ -->
<div class="view" id="v-text">
  <p class="mono" style="margin-bottom:0.4rem;">텍스트 데이터</p>
  <h2>자연어의 수치 표현</h2>
  <p class="desc">
    인공지능이 텍스트를 처리하려면 단어를 숫자로 변환해야 합니다.
    문장을 입력하면 원-핫 벡터와 빈도수 벡터로 변환하는 과정을 확인할 수 있습니다.
  </p>

  <div class="card">
    <h3>컴퓨터는 왜 문자를 이해하지 못할까?</h3>
    <p>컴퓨터는 본질적으로 숫자 계산기입니다. "고양이"라는 단어를 보고 귀엽고 작은 동물을 떠올리는 것은 인간만의 능력이며,
      컴퓨터에게 "고양이"는 의미 없는 문자 코드의 나열일 뿐입니다.
      AI가 텍스트를 처리하려면 단어를 숫자 벡터(숫자의 나열)로 변환해야 하며, 이 과정을 <strong>텍스트 벡터화</strong>라 합니다.</p>
    <p style="margin-top:0.5rem;">원-핫 인코딩은 가장 직관적인 변환 방법으로, 단어 집합에서 해당 단어의 위치만 1이고 나머지는 0인 벡터를 만듭니다.
      이해하기 쉽지만 단어 간 관계(예: "왕"과 "여왕"이 유사하다는 것)를 표현할 수 없고, 단어가 많아지면 벡터가 매우 커지는 단점이 있습니다.</p>
    <p style="margin-top:0.5rem;">빈도수 벡터(BoW)는 문장에서 각 단어가 몇 번 등장했는지를 세어 벡터로 표현합니다.
      스팸 메일 필터, 뉴스 기사 분류, 감성 분석 등에 널리 사용되었으며, TF-IDF, Word2Vec, BERT 등 더 발전된 기법의 기초가 됩니다.</p>
  </div>

  <div class="tabs">
    <button class="tab on" onclick="ttab(0,this)">원-핫 인코딩</button>
    <button class="tab" onclick="ttab(1,this)">빈도수 벡터</button>
  </div>

  <!-- TAB 0: One-Hot -->
  <div class="tpanel on" id="tt0">
    <div class="card">
      <h3>원-핫 인코딩 (One-Hot Encoding)</h3>
      <p>단어 집합에서 각 단어의 위치만 1이고 나머지는 모두 0인 벡터로 표현합니다.
        아래에 문장을 입력하면 각 단어의 원-핫 벡터를 확인할 수 있습니다.</p>
    </div>

    <div class="card">
      <h3>문장 입력</h3>
      <input type="text" id="oh-input" placeholder="예: 나는 인공지능 수학을 좋아한다" value="나는 인공지능 수학을 좋아한다"
        style="width:100%;padding:0.6rem 0.8rem;border:1px solid var(--border);border-radius:var(--radius);font-family:var(--sans);font-size:0.88rem;background:var(--bg);color:var(--fg);margin-top:0.5rem;">
      <div class="btn-row">
        <button class="btn pri" onclick="ohVocabUser=null;ohEncode()">인코딩</button>
      </div>
    </div>

    <div id="oh-result"></div>
  </div>

  <!-- TAB 1: BoW -->
  <div class="tpanel" id="tt1">
    <div class="card">
      <h3>빈도수 벡터 (Bag of Words)</h3>
      <p>문장을 띄어쓰기 기준으로 분리하고, 각 단어의 등장 횟수를 벡터로 표현합니다.
        여러 문장을 입력하면 각 문장의 빈도수 벡터를 비교할 수 있습니다.</p>
    </div>

    <div class="card">
      <h3>문장 입력 (줄바꿈으로 여러 문장 입력)</h3>
      <textarea id="bow-input" rows="4" placeholder="문장 1&#10;문장 2&#10;..."
        style="width:100%;padding:0.6rem 0.8rem;border:1px solid var(--border);border-radius:var(--radius);font-family:var(--sans);font-size:0.86rem;background:var(--bg);color:var(--fg);resize:vertical;margin-top:0.5rem;">오늘 날씨가 좋다
오늘 공부를 한다
인공지능 수학 공부가 재미있다</textarea>
      <div class="btn-row">
        <button class="btn pri" onclick="bowAnalyze()">분석</button>
        <button class="btn" onclick="bowAnimate()">단계별 애니메이션</button>
      </div>
    </div>

    <div id="bow-result"></div>
  </div>
</div>

<!-- ═══════════ OBJECT DETECTION ═══════════ -->
<div class="view" id="v-detect">
  <p class="mono" style="margin-bottom:0.4rem;">객체 탐지</p>
  <h2>AI가 이미지에서 물체를 찾는 과정</h2>
  <p class="desc">
    객체 탐지는 이미지 속에서 물체의 종류와 위치를 동시에 파악하는 기술입니다.
    이미지를 업로드하면 AI 모델이 물체를 인식하고 바운딩 박스로 표시합니다.
  </p>

  <div class="card">
    <h3>이미지 분류와 객체 탐지의 차이</h3>
    <p><strong>이미지 분류</strong>는 "이 사진에 고양이가 있는가?"라는 질문에 답합니다.
      사진 전체를 하나의 레이블로 분류하는 것이죠.
      반면 <strong>객체 탐지</strong>는 "이 사진에서 고양이가 어디에 있는가?"에 답합니다.
      여러 물체의 종류와 위치를 동시에 파악해야 하므로 훨씬 복잡한 문제입니다.</p>
    <p style="margin-top:0.5rem;">객체 탐지의 핵심 과정은 다음과 같습니다.
      먼저 합성곱 신경망(CNN)이 이미지에서 특징을 추출하고, 이 특징 맵을 바탕으로
      물체가 있을 만한 영역을 예측합니다. 각 영역에 대해 "이것이 무엇인가(분류)"와
      "정확한 위치는 어디인가(바운딩 박스 좌표)"를 동시에 출력합니다.</p>
  </div>

  <div class="card">
    <h3>실생활 속 객체 탐지</h3>
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(12rem,1fr));gap:0.8rem;margin-top:0.5rem;">
      <div class="cr"><strong>자율주행</strong> — 도로 위의 차량, 보행자, 신호등, 표지판을 실시간으로 인식하여 안전 운행 판단</div>
      <div class="cr"><strong>의료 영상</strong> — X-ray, CT, MRI에서 종양이나 골절 부위를 자동으로 찾아 의사의 진단을 보조</div>
      <div class="cr"><strong>제조 품질 관리</strong> — 생산 라인에서 부품의 결함, 스크래치, 조립 오류를 카메라로 검출</div>
      <div class="cr"><strong>보안 및 감시</strong> — CCTV 영상에서 이상 행동이나 침입자를 자동 감지하여 경보 발생</div>
    </div>
  </div>

  <div class="card">
    <h3>직접 체험하기</h3>
    <p>아래에 이미지를 업로드하면, COCO-SSD 모델이 브라우저에서 직접 실행되어 80종의 물체를 탐지합니다. 처음 실행 시 모델을 불러오는 데 수 초가 걸릴 수 있습니다.</p>
    <div class="upz" id="det-upz" style="margin-top:0.8rem;">
      <p style="font-weight:500;color:var(--fg);margin-bottom:0.2rem;">이미지를 드래그하거나 클릭하여 업로드하세요</p>
      <p style="font-size:0.7rem;margin-top:0.15rem;">jpg, png 등 이미지 파일을 지원합니다</p>
      <input type="file" id="det-fup" accept="image/*">
    </div>
    <div id="det-status" class="status"></div>
  </div>

  <div id="det-result" style="display:none;">
    <div class="card" style="text-align:center;">
      <div style="position:relative;display:inline-block;">
        <canvas id="det-canvas" class="cv" style="max-width:100%;"></canvas>
      </div>
    </div>

    <div class="card">
      <h3>탐지 결과</h3>
      <div id="det-list"></div>
    </div>
  </div>

  <div class="info">
    <strong>한계점과 발전 방향:</strong> 여기서 사용하는 COCO-SSD는 80개 클래스만 인식하는 경량 모델입니다.
    최신 연구에서는 수천 종의 객체를 인식하고, 물체의 윤곽선까지 정밀하게 추출하는
    인스턴스 분할(Instance Segmentation)이나 텍스트만으로 원하는 물체를 찾는
    개방형 어휘 탐지(Open-Vocabulary Detection) 등으로 발전하고 있습니다.
  </div>
</div>

</main>

<footer><div class="inner"><span>인공지능 수학 — 대전대신고등학교</span><span>2026</span></div></footer>

<script>
// ═══════════════════════════════════════════
//  NAVIGATION (SPA-style)
// ═══════════════════════════════════════════
let currentView='home';
function go(v,pushState=true){
  document.querySelectorAll('.view').forEach(el=>el.classList.remove('active'));
  document.getElementById('v-'+v).classList.add('active');
  document.querySelectorAll('.nav-btn').forEach(b=>b.classList.remove('active'));
  document.querySelector(`.nav-btn[data-v="${v}"]`).classList.add('active');
  window.scrollTo(0,0);
  currentView=v;
  if(pushState)try{history.pushState({view:v},'','#'+v);}catch(e){}
  // lazy init
  if(v==='filter'&&!srcImg){createDefImg();applyF();document.getElementById('up-status').textContent='기본 도형 이미지가 적용되었습니다. 직접 업로드하여 변경할 수 있습니다.';}
  if(v==='pool'){pRst();}
  if(v==='perceptron'&&!pcInited){pcInited=true;pcInit();}
}
document.querySelectorAll('.nav-btn').forEach(b=>b.addEventListener('click',()=>go(b.dataset.v)));

window.addEventListener('popstate',e=>{
  if(e.state&&e.state.view){go(e.state.view,false);}
  else{go('home',false);}
});

(()=>{try{const h=location.hash.replace('#','');if(h&&document.getElementById('v-'+h)){go(h);}else{history.replaceState({view:'home'},'','#home');}}catch(e){}})();

window.addEventListener('beforeunload',e=>{if(currentView!=='home'){e.preventDefault();}});

function htab(n,el){document.querySelectorAll('#v-hamming .tab').forEach(t=>t.classList.remove('on'));el.classList.add('on');document.querySelectorAll('#v-hamming .tpanel').forEach(p=>p.classList.remove('on'));document.getElementById('ht'+n).classList.add('on');}
function ctab(n,el){document.querySelectorAll('#v-conv .tab').forEach(t=>t.classList.remove('on'));el.classList.add('on');document.querySelectorAll('#v-conv .tpanel').forEach(p=>p.classList.remove('on'));document.getElementById('ct'+n).classList.add('on');}
function ptab(n,el){document.querySelectorAll('#v-pool .tab').forEach(t=>t.classList.remove('on'));el.classList.add('on');document.querySelectorAll('#v-pool .tpanel').forEach(p=>p.classList.remove('on'));document.getElementById('pt'+n).classList.add('on');}

// ═══════════════════════════════════════════
//  HAMMING XOR DEMO
// ═══════════════════════════════════════════
let hA=[1,0,1,1,0,0,1,0,1,0],hB=[1,1,0,1,0,1,1,0,0,1];
function rHD(){
  const box=document.getElementById('hd-box');box.innerHTML='';
  const mkRow=(lbl,arr,tog)=>{
    const r=document.createElement('div');r.style.cssText='display:flex;align-items:center;gap:2px;';
    const lb=document.createElement('span');lb.style.cssText='font-family:var(--mono);font-size:0.62rem;color:var(--muted);width:2.2rem;text-align:right;margin-right:0.3rem;';lb.textContent=lbl;r.appendChild(lb);
    arr.forEach((v,i)=>{const e=document.createElement('span');e.style.cssText=`display:inline-flex;align-items:center;justify-content:center;width:2.1rem;height:2.1rem;background:${v?'var(--fg)':'var(--card)'};color:${v?'var(--bg)':'var(--fg)'};font-family:var(--mono);font-size:0.8rem;font-weight:600;border-radius:4px;cursor:pointer;transition:all 0.12s;border:1px solid var(--border);`;e.textContent=v;if(tog)e.onclick=()=>{arr[i]^=1;rHD();};r.appendChild(e);});
    return r;
  };
  box.appendChild(mkRow('A',hA,true));box.appendChild(mkRow('B',hB,true));
  const xr=document.createElement('div');xr.style.cssText='display:flex;align-items:center;gap:2px;';
  const xl=document.createElement('span');xl.style.cssText='font-family:var(--mono);font-size:0.62rem;color:var(--muted);width:2.2rem;text-align:right;margin-right:0.3rem;';xl.textContent='A⊕B';xr.appendChild(xl);
  let d=0;for(let i=0;i<hA.length;i++){const x=hA[i]^hB[i];d+=x;const e=document.createElement('span');e.style.cssText=`display:inline-flex;align-items:center;justify-content:center;width:2.1rem;height:2.1rem;background:${x?'var(--red)':'var(--card)'};color:${x?'#fff':'var(--muted)'};font-family:var(--mono);font-size:0.8rem;font-weight:600;border-radius:4px;border:1px solid ${x?'var(--red)':'var(--border)'};`;e.textContent=x;xr.appendChild(e);}
  box.appendChild(xr);document.getElementById('hd-res').textContent=`해밍 거리 = ${d}`;
}
rHD();

// ═══════════════════════════════════════════
//  BITMAP
// ═══════════════════════════════════════════
let bSz=6,uBmp=[],isDraw=false,dVal=1;
const REFS={};
REFS[6]=[
  [0,1,1,1,1,0,1,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,1,1,1,1,0],
  [0,0,1,1,0,0,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1,1,1],
  [0,1,1,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,1,1,1,1],
  [1,1,1,1,1,0,0,0,0,0,1,1,0,0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,0],
  [1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,1,0,0],
  [1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,0],
  [0,1,1,1,1,0,1,1,0,0,0,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,1,1,1,1,0],
  [1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0],
  [0,1,1,1,1,0,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,1,1,0],
  [0,1,1,1,1,0,1,1,0,0,1,1,1,0,0,0,0,1,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,0],
];
REFS[8]=[
  [0,0,1,1,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,1,1,0,0,1,1,0,0,0,1,1,1,1,0,0],
  [0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0],
  [0,0,1,1,1,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0],
  [0,0,1,1,1,1,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0],
  [0,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0],
  [0,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0],
  [0,0,1,1,1,1,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,0,0,0,1,1,0,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,0,0],
  [0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0],
  [0,0,1,1,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,0,0],
  [0,0,1,1,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,0],
];
REFS[12]=(()=>{const r=[];for(let d=0;d<10;d++){const s=REFS[6][d],o=[];for(let y=0;y<6;y++){const r1=[],r2=[];for(let x=0;x<6;x++){const v=s[y*6+x];r1.push(v,v);r2.push(v,v);}o.push(...r1,...r2);}r.push(o);}return r;})();

function setSz(n,el){bSz=n;uBmp=Array(n*n).fill(0);document.querySelectorAll('.bsz').forEach(b=>b.classList.remove('active'));el.classList.add('active');rBmp();document.getElementById('hbars').innerHTML='<p style="font-size:0.8rem;color:var(--muted);">숫자를 그린 후 계산 버튼을 누르세요.</p>';document.getElementById('hbest').textContent='';rRef();}

function rBmp(){
  const g=document.getElementById('ubmp');const cs=bSz<=6?'2rem':bSz<=8?'1.6rem':'1.2rem';
  g.style.gridTemplateColumns=`repeat(${bSz},1fr)`;g.innerHTML='';
  for(let i=0;i<bSz*bSz;i++){const c=document.createElement('div');c.className='bc'+(uBmp[i]?' on':'');c.style.width=cs;c.style.height=cs;
    c.dataset.idx=i;
    c.addEventListener('mousedown',e=>{e.preventDefault();isDraw=true;dVal=uBmp[i]?0:1;uBmp[i]=dVal;rBmpVisual();});
    c.addEventListener('mouseenter',()=>{if(isDraw){uBmp[i]=dVal;rBmpVisual();}});
    g.appendChild(c);}
  bindTouch();
}

// Lightweight visual-only update (no DOM rebuild)
function rBmpVisual(){
  const cells=document.getElementById('ubmp').children;
  for(let i=0;i<cells.length;i++){cells[i].className='bc'+(uBmp[i]?' on':'');}
}

// Bind touch handlers once on the grid — survives rBmpVisual calls
function bindTouch(){
  const g=document.getElementById('ubmp');
  g.ontouchstart=e=>{
    e.preventDefault();
    const t=e.touches[0];
    const el=document.elementFromPoint(t.clientX,t.clientY);
    if(el&&el.dataset&&el.dataset.idx!==undefined){
      const idx=parseInt(el.dataset.idx);
      isDraw=true;dVal=uBmp[idx]?0:1;uBmp[idx]=dVal;rBmpVisual();
    }
  };
  g.ontouchmove=e=>{
    e.preventDefault();
    if(!isDraw)return;
    const t=e.touches[0];
    const el=document.elementFromPoint(t.clientX,t.clientY);
    if(el&&el.dataset&&el.dataset.idx!==undefined){
      const idx=parseInt(el.dataset.idx);
      if(uBmp[idx]!==dVal){uBmp[idx]=dVal;rBmpVisual();}
    }
  };
  g.ontouchend=()=>{isDraw=false;};
}
document.addEventListener('mouseup',()=>{isDraw=false;});

function rRef(){const b=document.getElementById('rbtn');b.innerHTML='';for(let d=0;d<10;d++){const e=document.createElement('button');e.className='btn';e.textContent=d;e.style.padding='0.35rem 0.55rem';e.onclick=()=>showRefPreview(d);b.appendChild(e);}}

function showRefPreview(digit){
  const ref=REFS[bSz][digit];
  const cs=bSz<=6?'1.2rem':bSz<=8?'1rem':'0.7rem';
  const box=document.getElementById('refpreview');
  let html=`<p class="mat-label" style="margin-bottom:0.3rem;">참조: 숫자 ${digit}</p>`;
  html+=`<div class="bmp" style="grid-template-columns:repeat(${bSz},1fr);cursor:default;">`;
  for(let i=0;i<bSz*bSz;i++){
    html+=`<div class="bc${ref[i]?' on':''}" style="width:${cs};height:${cs};pointer-events:none;"></div>`;
  }
  html+=`</div>`;
  box.innerHTML=html;
}

function clrBmp(){uBmp=Array(bSz*bSz).fill(0);rBmp();document.getElementById('hbars').innerHTML='<p style="font-size:0.8rem;color:var(--muted);">숫자를 그린 후 계산 버튼을 누르세요.</p>';document.getElementById('hbest').textContent='';document.getElementById('hoverlap').innerHTML='';document.getElementById('refpreview').innerHTML='';}

function calcH(){
  const refs=REFS[bSz];if(!refs)return;const tot=bSz*bSz;
  const ds=refs.map((ref,i)=>{let d=0;for(let j=0;j<tot;j++)d+=(uBmp[j]^ref[j]);return{digit:i,dist:d,sim:((tot-d)/tot*100).toFixed(1)};});
  const mx=Math.max(...ds.map(d=>d.dist),1),mn=Math.min(...ds.map(d=>d.dist));
  const box=document.getElementById('hbars');box.innerHTML='';
  ds.forEach(({digit,dist,sim})=>{const e=document.createElement('div');e.className='hb';e.innerHTML=`<span class="dl">${digit}</span><div class="tk"><div class="fl ${dist===mn?'best':''}" style="width:${dist/mx*100}%"></div></div><span class="dv">${dist} (${sim}%)</span>`;box.appendChild(e);});
  const best=ds.reduce((a,b)=>a.dist<b.dist?a:b);
  document.getElementById('hbest').textContent=`가장 유사: ${best.digit} (거리 ${best.dist}, 유사도 ${best.sim}%)`;

  // Overlap comparison grid
  const ovBox=document.getElementById('hoverlap');
  const bestRef=refs[best.digit];
  const cs=bSz<=6?'1.4rem':bSz<=8?'1.1rem':'0.8rem';
  let ovHtml=`<p class="mat-label" style="margin-bottom:0.4rem;">내 그림 vs 숫자 ${best.digit} 겹침 비교</p>`;
  ovHtml+=`<div class="ovlap" style="grid-template-columns:repeat(${bSz},1fr);">`;
  for(let i=0;i<tot;i++){
    const u=uBmp[i],r=bestRef[i];
    let cls;
    if(u===1&&r===1) cls='both';       // 둘 다 검정
    else if(u===0&&r===0) cls='match';  // 둘 다 흰색
    else if(u===1&&r===0) cls='only-user'; // 내 그림에만 있음
    else cls='only-ref';                // 참조에만 있음
    ovHtml+=`<div class="oc ${cls}" style="width:${cs};height:${cs};"></div>`;
  }
  ovHtml+=`</div>`;
  ovHtml+=`<div style="display:flex;gap:0.8rem;margin-top:0.5rem;flex-wrap:wrap;">`;
  ovHtml+=`<span style="font-size:0.62rem;color:var(--muted);display:flex;align-items:center;gap:0.25rem;"><span style="display:inline-block;width:0.6rem;height:0.6rem;background:var(--fg);border-radius:2px;"></span>일치 (둘 다 검정)</span>`;
  ovHtml+=`<span style="font-size:0.62rem;color:var(--muted);display:flex;align-items:center;gap:0.25rem;"><span style="display:inline-block;width:0.6rem;height:0.6rem;background:var(--red);opacity:0.7;border-radius:2px;"></span>내 그림에만</span>`;
  ovHtml+=`<span style="font-size:0.62rem;color:var(--muted);display:flex;align-items:center;gap:0.25rem;"><span style="display:inline-block;width:0.6rem;height:0.6rem;background:var(--blue);opacity:0.7;border-radius:2px;"></span>참조에만</span>`;
  ovHtml+=`</div>`;
  ovBox.innerHTML=ovHtml;
}

uBmp=Array(bSz*bSz).fill(0);rBmp();rRef();

// ═══════════════════════════════════════════
//  EDIT GRID HELPER
// ═══════════════════════════════════════════
function mkEG(id,data,rows,cols,onCh){
  const g=document.getElementById(id);g.innerHTML='';g.style.gridTemplateColumns=`repeat(${cols},1fr)`;
  for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){
    const cell=document.createElement('div');cell.className='ec';
    const inp=document.createElement('input');inp.type='number';inp.value=data[r][c];
    inp.addEventListener('change',()=>{data[r][c]=parseInt(inp.value)||0;if(onCh)onCh();});
    inp.addEventListener('focus',()=>inp.select());
    cell.appendChild(inp);g.appendChild(cell);
  }
}

// ═══════════════════════════════════════════
//  MANUAL CONV
// ═══════════════════════════════════════════
let mI=[[1,2,0,1],[0,1,3,2],[1,0,2,1],[2,1,0,3]],mK=[[1,0,-1],[0,1,0],[-1,0,1]],mO=[[0,0],[0,0]];

function newMan(){
  for(let r=0;r<4;r++)for(let c=0;c<4;c++)mI[r][c]=Math.floor(Math.random()*5);
  const ks=[[[1,0,-1],[0,1,0],[-1,0,1]],[[0,-1,0],[-1,5,-1],[0,-1,0]],[[1,1,1],[0,0,0],[-1,-1,-1]]];
  const p=ks[Math.floor(Math.random()*ks.length)];for(let r=0;r<3;r++)for(let c=0;c<3;c++)mK[r][c]=p[r][c];
  mO=[[0,0],[0,0]];mkEG('mi',mI,4,4);mkEG('mk',mK,3,3);mkEG('mo',mO,2,2);
  document.getElementById('mres').style.display='none';document.getElementById('msol').style.display='none';
}

function chkMan(){
  const cor=[];
  for(let r=0;r<2;r++){cor.push([]);for(let c=0;c<2;c++){let s=0;for(let kr=0;kr<3;kr++)for(let kc=0;kc<3;kc++)s+=mI[r+kr][c+kc]*mK[kr][kc];cor[r].push(s);}}
  let ok=true;const det=[];
  for(let r=0;r<2;r++)for(let c=0;c<2;c++){
    const right=mO[r][c]===cor[r][c];if(!right)ok=false;
    let t=[];for(let kr=0;kr<3;kr++)for(let kc=0;kc<3;kc++)t.push(`${mI[r+kr][c+kc]}×(${mK[kr][kc]})`);
    det.push(`위치(${r},${c}): ${t.join(' + ')} = ${cor[r][c]}${right?'':' (입력값: '+mO[r][c]+')'}`);
  }
  const res=document.getElementById('mres');res.style.display='block';
  res.innerHTML=ok?'<strong>정답입니다.</strong>':'<strong>일부 틀렸습니다.</strong> 아래 풀이를 확인하세요.';
  res.style.borderLeftColor=ok?'var(--green)':'var(--red)';
  const sol=document.getElementById('msol');sol.style.display='block';
  sol.innerHTML=`<div class="card"><h3>풀이 과정</h3>${det.map(d=>'<p style="font-size:0.8rem;color:var(--muted);font-family:var(--mono);margin:0.25rem 0;">'+d+'</p>').join('')}</div>`;
}
newMan();

// ═══════════════════════════════════════════
//  AUTO CONV VIZ
// ═══════════════════════════════════════════
const AI=[[0,0,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[0,1,1,1,0],[0,0,0,0,0]];
const AK=[[1,0,1],[0,1,0],[1,0,1]];
let ap=-1,ar=Array(9).fill('?');

function bldA(){
  ['ai','ak','ao'].forEach(id=>document.getElementById(id).innerHTML='');
  for(let r=0;r<5;r++)for(let c=0;c<5;c++){const e=document.createElement('div');e.className='mc';e.id=`ai${r}${c}`;e.textContent=AI[r][c];document.getElementById('ai').appendChild(e);}
  for(let r=0;r<3;r++)for(let c=0;c<3;c++){const e=document.createElement('div');e.className='mc';e.textContent=AK[r][c];document.getElementById('ak').appendChild(e);}
  for(let i=0;i<9;i++){const e=document.createElement('div');e.className='mc';e.id=`ao${i}`;e.textContent=ar[i];document.getElementById('ao').appendChild(e);}
}
bldA();



function aStep(){
  ap++;if(ap>=9){ap=8;return;}
  const row=Math.floor(ap/3),col=ap%3;
  for(let r=0;r<5;r++)for(let c=0;c<5;c++)document.getElementById(`ai${r}${c}`).className='mc';
  let sum=0,terms=[];
  // First pass: highlight entire window
  for(let kr=0;kr<3;kr++)for(let kc=0;kc<3;kc++){
    const ir=row+kr,ic=col+kc;
    document.getElementById(`ai${ir}${ic}`).className='mc win';
  }
  // Second pass: emphasize cells where kernel is nonzero (active multipliers)
  for(let kr=0;kr<3;kr++)for(let kc=0;kc<3;kc++){
    const ir=row+kr,ic=col+kc;
    const kv=AK[kr][kc];
    if(kv!==0) document.getElementById(`ai${ir}${ic}`).className='mc win-active';
    const p=AI[ir][ic]*kv;sum+=p;terms.push(`(${AI[ir][ic]}×${kv})`);
  }
  ar[ap]=sum;
  for(let i=0;i<9;i++){const e=document.getElementById(`ao${i}`);e.textContent=ar[i];e.className=i===ap?'mc res':ar[i]!=='?'?'mc done':'mc';}
  document.getElementById('ast').textContent=`위치 (${row}, ${col}) → ${sum}`;
  document.getElementById('acalc').innerHTML=`<strong>계산:</strong> ${terms.join(' + ')} = <strong>${sum}</strong><br><span style="font-size:0.65rem;">진한 색 = 필터값이 0이 아닌 곳 (실제 곱셈 발생) · 연한 색 = 필터값 0 (곱해도 0)</span>`;
}

let aIv=null;
function aAuto(){if(aIv){clearInterval(aIv);aIv=null;}aReset();let s=0;aIv=setInterval(()=>{aStep();s++;if(s>=9){clearInterval(aIv);aIv=null;}},800);}
function aReset(){if(aIv){clearInterval(aIv);aIv=null;}ap=-1;ar=Array(9).fill('?');bldA();document.getElementById('ast').textContent='';document.getElementById('acalc').innerHTML='시작 버튼을 눌러 연산 과정을 확인하세요.';}

// ═══════════════════════════════════════════
//  FILTER PLAYGROUND
// ═══════════════════════════════════════════
const FL={
  'Identity':{k:[[0,0,0],[0,1,0],[0,0,0]],d:'원본 그대로 출력합니다.'},
  'Sobel X':{k:[[-1,0,1],[-2,0,2],[-1,0,1]],d:'세로선(수직 경계)을 검출합니다.'},
  'Sobel Y':{k:[[-1,-2,-1],[0,0,0],[1,2,1]],d:'가로선(수평 경계)을 검출합니다.'},
  'Sharpen':{k:[[0,-1,0],[-1,5,-1],[0,-1,0]],d:'경계를 또렷하게 선명화합니다.'},
  'Box Blur':{k:[[1,1,1],[1,1,1],[1,1,1]],d:'주변 9픽셀 평균으로 흐리게 합니다.',n:9},
  'Edge':{k:[[-1,-1,-1],[-1,8,-1],[-1,-1,-1]],d:'윤곽선만 추출합니다.'},
};
let aF='Identity',srcImg=null,cK=[[0,0,0],[0,1,0],[0,0,0]];

function bldFC(){
  const box=document.getElementById('fc');box.innerHTML='';
  Object.keys(FL).forEach(n=>{const ch=document.createElement('button');ch.className='chip'+(n===aF?' on':'');ch.textContent=n;
    ch.onclick=()=>{aF=n;document.querySelectorAll('#fc .chip').forEach(c=>c.classList.remove('on'));ch.classList.add('on');cK=FL[n].k.map(r=>[...r]);rFK();applyF();};
    box.appendChild(ch);});
}
function rFK(){mkEG('fk',cK,3,3);const f=FL[aF];document.getElementById('fd').textContent=f?f.d:'커스텀 커널';}
function applyCustom(){aF='Custom';document.querySelectorAll('#fc .chip').forEach(c=>c.classList.remove('on'));document.getElementById('fd').textContent='사용자 정의 커널 적용';applyF();}

function createDefImg(){
  const cv=document.getElementById('fin'),ctx=cv.getContext('2d'),W=240;
  ctx.fillStyle='#e8e0d6';ctx.fillRect(0,0,W,W);
  ctx.fillStyle='#3a342e';ctx.beginPath();ctx.arc(120,75,45,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#78726a';ctx.fillRect(35,155,70,55);
  ctx.fillStyle='#a89888';ctx.beginPath();ctx.moveTo(180,210);ctx.lineTo(145,155);ctx.lineTo(215,155);ctx.closePath();ctx.fill();
  ctx.strokeStyle='#1a1714';ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(25,25);ctx.lineTo(70,70);ctx.stroke();
  ctx.beginPath();ctx.moveTo(165,25);ctx.lineTo(215,25);ctx.stroke();ctx.beginPath();ctx.moveTo(190,15);ctx.lineTo(190,55);ctx.stroke();
  for(let i=0;i<10;i++){ctx.fillStyle='#1a1714';ctx.beginPath();ctx.arc(25+i*21,120,3,0,Math.PI*2);ctx.fill();}
  srcImg=ctx.getImageData(0,0,W,W);
}

function loadImg(file){
  const reader=new FileReader();reader.onload=e=>{const img=new Image();img.onload=()=>{
    const cv=document.getElementById('fin'),ctx=cv.getContext('2d');ctx.clearRect(0,0,240,240);
    const sc=Math.min(240/img.width,240/img.height),w=img.width*sc,h=img.height*sc;
    ctx.fillStyle='#e8e0d6';ctx.fillRect(0,0,240,240);ctx.drawImage(img,(240-w)/2,(240-h)/2,w,h);
    srcImg=ctx.getImageData(0,0,240,240);applyF();
    document.getElementById('up-status').textContent='이미지가 적용되었습니다. (' +file.name+')';
    document.getElementById('upz').style.borderColor='var(--green)';
    setTimeout(()=>{document.getElementById('upz').style.borderColor='';},2000);
  };img.src=e.target.result;};reader.readAsDataURL(file);
}

const uz=document.getElementById('upz'),fi=document.getElementById('fup');
uz.onclick=()=>fi.click();fi.onchange=e=>{if(e.target.files[0])loadImg(e.target.files[0]);};
uz.ondragover=e=>{e.preventDefault();uz.classList.add('dg');};uz.ondragleave=()=>uz.classList.remove('dg');
uz.ondrop=e=>{e.preventDefault();uz.classList.remove('dg');if(e.dataTransfer.files[0])loadImg(e.dataTransfer.files[0]);};

function applyF(){
  if(!srcImg)return;const k=cK,f=FL[aF],norm=f&&f.n?f.n:1;
  const W=srcImg.width,H=srcImg.height,oc=document.getElementById('fout'),octx=oc.getContext('2d'),out=octx.createImageData(W,H);
  for(let y=1;y<H-1;y++)for(let x=1;x<W-1;x++){
    let r=0,g=0,b=0;
    for(let ky=-1;ky<=1;ky++)for(let kx=-1;kx<=1;kx++){const idx=((y+ky)*W+(x+kx))*4,w=k[ky+1][kx+1];r+=srcImg.data[idx]*w;g+=srcImg.data[idx+1]*w;b+=srcImg.data[idx+2]*w;}
    const oi=(y*W+x)*4;out.data[oi]=Math.min(255,Math.max(0,r/norm));out.data[oi+1]=Math.min(255,Math.max(0,g/norm));out.data[oi+2]=Math.min(255,Math.max(0,b/norm));out.data[oi+3]=255;
  }
  octx.putImageData(out,0,0);
}

bldFC();rFK();

// ═══════════════════════════════════════════
//  POOLING
// ═══════════════════════════════════════════
let pI=[[9,8,4,8],[7,9,4,8],[2,8,9,7],[6,5,9,5]],pP=-1,pR=['?','?','?','?'],pIv=null;

function bldP(){
  mkEG('pi',pI,4,4);
  const o=document.getElementById('po');o.innerHTML='';
  for(let i=0;i<4;i++){const e=document.createElement('div');e.className='mc';e.id=`po${i}`;e.textContent=pR[i];o.appendChild(e);}
}

function pRst(){if(pIv){clearInterval(pIv);pIv=null;}pP=-1;pR=['?','?','?','?'];bldP();document.getElementById('pst').textContent='';}

function pStp(){
  pP++;if(pP>=4){pP=3;return;}
  const sr=pP<2?0:2,sc=pP%2===0?0:2;
  // Clear all highlights
  document.querySelectorAll('#pi .ec').forEach(c=>{c.style.background='';c.style.outline='';const inp=c.querySelector('input');if(inp)inp.style.color='';});
  // Find max
  let mx=-Infinity;
  for(let r=sr;r<sr+2;r++)for(let c=sc;c<sc+2;c++){if(pI[r][c]>mx)mx=pI[r][c];}
  // Highlight: window cells get accent, max cell gets green
  for(let r=sr;r<sr+2;r++)for(let c=sc;c<sc+2;c++){
    const idx=r*4+c,cells=document.getElementById('pi').children;
    const isMax=pI[r][c]===mx;
    cells[idx].style.background=isMax?'var(--green)':'var(--fg)';
    cells[idx].querySelector('input').style.color=isMax?'#fff':'var(--bg)';
    if(isMax)cells[idx].style.outline='2px solid var(--green)';
  }
  pR[pP]=mx;
  for(let i=0;i<4;i++){const e=document.getElementById(`po${i}`);e.textContent=pR[i];e.className=i===pP?'mc res':pR[i]!=='?'?'mc done':'mc';}
  document.getElementById('pst').textContent=`${sr}~${sr+1}행, ${sc}~${sc+1}열 → max = ${mx}`;
}

function pAut(){if(pIv){clearInterval(pIv);pIv=null;}pRst();let s=0;pIv=setInterval(()=>{pStp();s++;if(s>=4){clearInterval(pIv);pIv=null;}},1000);}

pRst();

// ═══════════════════════════════════════════
//  PERCEPTRON
// ═══════════════════════════════════════════
const PC_N=3;
let pcInputs=[1,0.5,-0.3];
let pcWeights=[0.8,-0.5,0.6];
let pcBias=0;
let pcAct='step';
let pcTheta=0;

const PC_ACTS={
  'step':{name:'계단 함수',hasTheta:true},
  'relu':{name:'ReLU',hasTheta:true},
  'sigmoid':{name:'시그모이드',hasTheta:false},
};

function pcInit(){
  // Build input controls
  const box=document.getElementById('pc-inputs');
  box.innerHTML='';
  for(let i=0;i<PC_N;i++){
    const row=document.createElement('div');
    row.style.cssText='display:flex;align-items:center;gap:0.6rem;margin-bottom:0.8rem;';
    row.innerHTML=`
      <span class="mono" style="width:1.5rem;flex-shrink:0;">x${i+1}</span>
      <input type="range" class="ns" id="pc-x${i}" min="-2" max="2" step="0.05" value="${pcInputs[i]}" style="max-width:10rem;flex:1;">
      <span id="pc-xv${i}" style="font-family:var(--mono);font-size:0.78rem;min-width:2.5rem;text-align:right;">${pcInputs[i].toFixed(2)}</span>
      <span class="mono" style="color:var(--muted);flex-shrink:0;">w${i+1}</span>
      <input type="number" id="pc-w${i}" value="${pcWeights[i]}" step="0.1" style="width:4rem;font-family:var(--mono);font-size:0.78rem;padding:0.3rem 0.4rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--card);color:var(--fg);text-align:center;">
    `;
    box.appendChild(row);
    // Events
    document.getElementById(`pc-x${i}`).addEventListener('input',function(){
      pcInputs[i]=parseFloat(this.value);
      document.getElementById(`pc-xv${i}`).textContent=pcInputs[i].toFixed(2);
      pcUpdate();
    });
    document.getElementById(`pc-w${i}`).addEventListener('input',function(){
      pcWeights[i]=parseFloat(this.value)||0;
      pcUpdate();
    });
  }

  // Bias slider
  document.getElementById('pc-bias').addEventListener('input',function(){
    pcBias=parseFloat(this.value);
    document.getElementById('pc-bias-val').textContent=pcBias.toFixed(1);
    pcUpdate();
  });

  // Activation chips
  const actBox=document.getElementById('pc-act-chips');
  actBox.innerHTML='';
  Object.keys(PC_ACTS).forEach(key=>{
    const ch=document.createElement('button');
    ch.className='chip'+(key===pcAct?' on':'');
    ch.textContent=PC_ACTS[key].name;
    ch.onclick=()=>{
      pcAct=key;
      actBox.querySelectorAll('.chip').forEach(c=>c.classList.remove('on'));
      ch.classList.add('on');
      document.getElementById('pc-threshold-wrap').style.display=PC_ACTS[key].hasTheta?'block':'none';
      pcUpdate();
    };
    actBox.appendChild(ch);
  });

  // Theta slider
  document.getElementById('pc-theta').addEventListener('input',function(){
    pcTheta=parseFloat(this.value);
    document.getElementById('pc-theta-val').textContent=pcTheta.toFixed(1);
    pcUpdate();
  });

  pcUpdate();
}

function pcActivate(x){
  switch(pcAct){
    case 'step': return x>=pcTheta?1:0;
    case 'relu': return x>=pcTheta?x-pcTheta:0;
    case 'sigmoid': return 1/(1+Math.exp(-(x)));
  }
}

function pcUpdate(){
  // Weighted sum
  let wsum=pcBias;
  const terms=[];
  for(let i=0;i<PC_N;i++){
    wsum+=pcInputs[i]*pcWeights[i];
    terms.push(`(${pcInputs[i].toFixed(2)} × ${pcWeights[i].toFixed(1)})`);
  }
  const y=pcActivate(wsum);

  // Show calc
  const calcEl=document.getElementById('pc-calc');
  calcEl.innerHTML=
    `가중합: ${terms.join(' + ')} + ${pcBias.toFixed(1)}<br>`+
    `<span style="color:var(--fg);font-weight:600;">x = ${wsum.toFixed(3)}</span><br>`+
    `f(x) = ${pcAct==='step'?'계단(θ='+pcTheta.toFixed(1)+')':pcAct==='relu'?'ReLU(θ='+pcTheta.toFixed(1)+')':'σ(x)'}`;

  document.getElementById('pc-output').textContent=y.toFixed(4);

  pcDrawGraph(wsum,y);
}

function pcDrawGraph(curX,curY){
  const cv=document.getElementById('pc-graph');
  const ctx=cv.getContext('2d');
  const W=cv.width,H=cv.height;
  const pad=40;

  ctx.clearRect(0,0,W,H);

  // Graph range
  const xMin=-6,xMax=6,yMin=-0.5,yMax=pcAct==='relu'?4:1.5;

  const toSX=x=>pad+(x-xMin)/(xMax-xMin)*(W-2*pad);
  const toSY=y=>H-pad-(y-yMin)/(yMax-yMin)*(H-2*pad);

  // Grid
  ctx.strokeStyle='#e8e0d6';
  ctx.lineWidth=1;
  for(let gx=Math.ceil(xMin);gx<=Math.floor(xMax);gx++){
    const sx=toSX(gx);
    ctx.beginPath();ctx.moveTo(sx,pad);ctx.lineTo(sx,H-pad);ctx.stroke();
  }
  for(let gy=Math.ceil(yMin*2)/2;gy<=yMax;gy+=0.5){
    const sy=toSY(gy);
    ctx.beginPath();ctx.moveTo(pad,sy);ctx.lineTo(W-pad,sy);ctx.stroke();
  }

  // Axes
  ctx.strokeStyle='#c8b9a6';
  ctx.lineWidth=1.5;
  // X axis
  const ax0=toSY(0);
  ctx.beginPath();ctx.moveTo(pad,ax0);ctx.lineTo(W-pad,ax0);ctx.stroke();
  // Y axis
  const ay0=toSX(0);
  ctx.beginPath();ctx.moveTo(ay0,pad);ctx.lineTo(ay0,H-pad);ctx.stroke();

  // Axis labels
  ctx.fillStyle='#78726a';
  ctx.font='11px "JetBrains Mono"';
  ctx.textAlign='center';
  for(let gx=Math.ceil(xMin);gx<=Math.floor(xMax);gx++){
    if(gx===0)continue;
    ctx.fillText(gx,toSX(gx),ax0+14);
  }
  ctx.textAlign='right';
  for(let gy=0;gy<=yMax;gy+=0.5){
    if(gy===0)continue;
    const sy=toSY(gy);
    if(sy>pad&&sy<H-pad) ctx.fillText(gy.toFixed(1),ay0-6,sy+4);
  }

  // Threshold line (for step and relu)
  if(pcAct!=='sigmoid'){
    const tx=toSX(pcTheta);
    ctx.strokeStyle='#4a6b8a';
    ctx.lineWidth=1;
    ctx.setLineDash([4,4]);
    ctx.beginPath();ctx.moveTo(tx,pad);ctx.lineTo(tx,H-pad);ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='#4a6b8a';
    ctx.textAlign='center';
    ctx.fillText('θ='+pcTheta.toFixed(1),tx,pad-6);
  }

  // Function curve
  ctx.strokeStyle='#1a1714';
  ctx.lineWidth=2.5;
  ctx.beginPath();
  let first=true;
  for(let px=pad;px<=W-pad;px++){
    const x=xMin+(px-pad)/(W-2*pad)*(xMax-xMin);
    const y=pcActivate(x);
    const sy=toSY(y);
    if(sy<pad-10||sy>H-pad+10){if(!first){ctx.stroke();ctx.beginPath();first=true;}continue;}
    if(first){ctx.moveTo(px,sy);first=false;}
    else ctx.lineTo(px,sy);
  }
  ctx.stroke();

  // Current point
  const px=toSX(curX),py=toSY(curY);
  // Dashed lines to point
  ctx.strokeStyle='#b44133';
  ctx.lineWidth=1;
  ctx.setLineDash([3,3]);
  ctx.beginPath();ctx.moveTo(px,ax0);ctx.lineTo(px,py);ctx.stroke();
  ctx.beginPath();ctx.moveTo(ay0,py);ctx.lineTo(px,py);ctx.stroke();
  ctx.setLineDash([]);

  // Point
  ctx.fillStyle='#b44133';
  ctx.beginPath();ctx.arc(px,py,6,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#fff';
  ctx.beginPath();ctx.arc(px,py,2.5,0,Math.PI*2);ctx.fill();

  // Label
  ctx.fillStyle='#b44133';
  ctx.font='bold 11px "JetBrains Mono"';
  ctx.textAlign='left';
  ctx.fillText(`(${curX.toFixed(2)}, ${curY.toFixed(4)})`,px+10,py-8);

  // Function name
  ctx.fillStyle='#1a1714';
  ctx.font='bold 12px "Noto Sans KR"';
  ctx.textAlign='left';
  const fname=pcAct==='step'?'계단 함수':pcAct==='relu'?'ReLU':'시그모이드';
  ctx.fillText('f(x) = '+fname,pad+4,pad-8);
}

// Lazy init on first visit
let pcInited=false;

function ttab(n,el){document.querySelectorAll('#v-text .tab').forEach(t=>t.classList.remove('on'));el.classList.add('on');document.querySelectorAll('#v-text .tpanel').forEach(p=>p.classList.remove('on'));document.getElementById('tt'+n).classList.add('on');}

// ═══════════════════════════════════════════
//  ONE-HOT ENCODING
// ═══════════════════════════════════════════
function ohEncode(){
  const text=document.getElementById('oh-input').value;
  const words=text.trim().replace(/[.,!?;:'"()]/g,'').split(/\s+/).filter(w=>w.length>0);
  if(words.length===0)return;

  // Build default vocabulary (unique words in order of appearance)
  const defaultVocab=[];
  words.forEach(w=>{if(!defaultVocab.includes(w))defaultVocab.push(w);});

  const vocab=ohVocabUser||defaultVocab;

  const box=document.getElementById('oh-result');
  const colors=['#b44133','#4a6b8a','#5a7a5a','#8a6a4a','#6a4a8a','#4a8a7a','#8a4a6a','#7a8a4a','#4a5a8a','#8a7a4a'];
  let html='';

  // Editable vocabulary
  html+=`<div class="card"><h3>단어 집합 (편집 가능)</h3>`;
  html+=`<p style="margin-bottom:0.5rem;">총 ${vocab.length}개 — 단어를 추가/삭제하여 직접 수정할 수 있습니다.</p>`;
  html+=`<div style="display:flex;flex-wrap:wrap;gap:0.3rem;margin-bottom:0.6rem;">`;
  vocab.forEach((w,i)=>{
    const c=colors[i%colors.length];
    html+=`<span style="display:inline-flex;align-items:center;gap:0.25rem;font-family:var(--mono);font-size:0.72rem;padding:0.2rem 0.5rem;border-radius:9999px;background:${c}18;color:${c};border:1px solid ${c}30;">[${i}] ${w}<button onclick="ohRemoveVocab(${i})" style="border:none;background:none;color:${c};cursor:pointer;font-size:0.8rem;padding:0;line-height:1;">×</button></span>`;
  });
  html+=`</div>`;
  html+=`<div style="display:flex;gap:0.3rem;align-items:center;">`;
  html+=`<input type="text" id="oh-vocab-add" placeholder="단어 추가" style="padding:0.35rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);font-family:var(--mono);font-size:0.75rem;background:var(--bg);color:var(--fg);width:8rem;">`;
  html+=`<button class="btn" onclick="ohAddVocab()">추가</button>`;
  html+=`<button class="btn" onclick="ohResetVocab()">기본값 복원</button>`;
  html+=`</div></div>`;

  // Highlighted sentence
  html+=`<div class="card"><h3>단어 집합 매칭</h3><p style="margin-bottom:0.5rem;">집합에 포함된 단어만 색상으로 표시됩니다.</p>`;
  html+=`<div style="display:flex;flex-wrap:wrap;gap:0.3rem;">`;
  words.forEach(w=>{
    const vi=vocab.indexOf(w);
    if(vi>=0){
      const c=colors[vi%colors.length];
      html+=`<span style="display:inline-block;padding:0.25rem 0.5rem;border-radius:var(--radius);font-family:var(--mono);font-size:0.82rem;font-weight:600;background:${c}20;color:${c};border:1px solid ${c}40;">${w}</span>`;
    }else{
      html+=`<span style="display:inline-block;padding:0.25rem 0.5rem;border-radius:var(--radius);font-family:var(--mono);font-size:0.82rem;background:var(--card);color:var(--muted);opacity:0.5;">${w}</span>`;
    }
  });
  html+=`</div></div>`;

  // One-hot vectors table
  html+=`<div class="card"><h3>원-핫 벡터</h3>`;
  html+=`<div style="overflow-x:auto;"><table style="border-collapse:collapse;margin-top:0.5rem;width:100%;">`;
  html+=`<tr><td style="padding:0.4rem 0.6rem;font-family:var(--mono);font-size:0.62rem;color:var(--muted);border-bottom:1px solid var(--border);">단어</td>`;
  vocab.forEach((w,i)=>{
    const c=colors[i%colors.length];
    html+=`<td style="padding:0.4rem 0.3rem;text-align:center;font-family:var(--mono);font-size:0.58rem;color:${c};border-bottom:1px solid var(--border);min-width:2rem;">${w}</td>`;
  });
  html+=`</tr>`;
  vocab.forEach((w,wi)=>{
    const c=colors[wi%colors.length];
    html+=`<tr><td style="padding:0.4rem 0.6rem;font-family:var(--mono);font-size:0.78rem;font-weight:600;color:${c};border-bottom:1px solid var(--border);white-space:nowrap;">${w}</td>`;
    vocab.forEach((_,j)=>{
      const v=j===wi?1:0;
      html+=`<td style="padding:0.4rem 0.3rem;text-align:center;font-family:var(--mono);font-size:0.78rem;font-weight:${v?'700':'400'};background:${v?c+'dd':'transparent'};color:${v?'#fff':'var(--muted)'};border-bottom:1px solid var(--border);border-radius:${v?'3px':'0'};">${v}</td>`;
    });
    html+=`</tr>`;
  });
  html+=`</table></div></div>`;

  html+=`<div class="info"><strong>원-핫 인코딩의 한계:</strong> 단어 집합이 커지면 벡터 차원이 급격히 증가하고, 단어 간 유사도를 표현할 수 없습니다. 이를 개선한 것이 Word2Vec 등의 워드 임베딩 방법입니다.</div>`;

  box.innerHTML=html;
}

function ohRemoveVocab(idx){
  const text=document.getElementById('oh-input').value;
  const words=text.trim().replace(/[.,!?;:'"()]/g,'').split(/\s+/).filter(w=>w.length>0);
  const defaultVocab=[];words.forEach(w=>{if(!defaultVocab.includes(w))defaultVocab.push(w);});
  const current=ohVocabUser||[...defaultVocab];
  current.splice(idx,1);
  ohVocabUser=current;
  ohEncode();
}

function ohAddVocab(){
  const inp=document.getElementById('oh-vocab-add');
  const w=inp.value.trim();if(!w)return;
  const text=document.getElementById('oh-input').value;
  const words=text.trim().replace(/[.,!?;:'"()]/g,'').split(/\s+/).filter(w=>w.length>0);
  const defaultVocab=[];words.forEach(w=>{if(!defaultVocab.includes(w))defaultVocab.push(w);});
  const current=ohVocabUser||[...defaultVocab];
  if(!current.includes(w)){current.push(w);ohVocabUser=current;ohEncode();}
}

function ohResetVocab(){ohVocabUser=null;ohEncode();}

// ═══════════════════════════════════════════
//  BAG OF WORDS
// ═══════════════════════════════════════════
// ═══════════════════════════════════════════
//  ONE-HOT ENCODING
// ═══════════════════════════════════════════
let ohVocabUser=null;

function bowProcess(sentences){
  const results=sentences.map(s=>{
    const words=s.trim().replace(/[.,!?;:'"()]/g,'').split(/\s+/).filter(w=>w.length>0);
    return {original:s, words};
  });

  // Build vocabulary from all words
  const vocab=[];
  results.forEach(r=>r.words.forEach(w=>{if(!vocab.includes(w))vocab.push(w);}));
  vocab.sort();

  // Count frequencies
  results.forEach(r=>{
    r.freq={};
    vocab.forEach(w=>{r.freq[w]=0;});
    r.words.forEach(w=>{r.freq[w]++;});
  });

  return {results,vocab};
}

function bowRenderResult(data){
  const {results,vocab}=data;
  const box=document.getElementById('bow-result');
  const colors=['#b44133','#4a6b8a','#5a7a5a','#8a6a4a','#6a4a8a','#4a8a7a','#8a4a6a','#7a8a4a'];
  let html='';

  // Step 1: Show word splitting per sentence
  results.forEach((r,si)=>{
    html+=`<div class="card"><h3>문장 ${si+1}: ${r.original}</h3>`;
    html+=`<p class="mono" style="margin-bottom:0.4rem;">띄어쓰기 기준 분리</p>`;
    html+=`<div style="display:flex;flex-wrap:wrap;gap:0.3rem;">`;
    r.words.forEach(w=>{
      html+=`<span style="display:inline-block;padding:0.2rem 0.45rem;border-radius:var(--radius);font-family:var(--mono);font-size:0.78rem;background:var(--fg);color:var(--bg);font-weight:500;">${w}</span>`;
    });
    html+=`</div></div>`;
  });

  // Step 2: Vocabulary
  html+=`<div class="card"><h3>단어 집합</h3>`;
  html+=`<div style="display:flex;flex-wrap:wrap;gap:0.3rem;">`;
  vocab.forEach((w,i)=>{
    const c=colors[i%colors.length];
    html+=`<span style="font-family:var(--mono);font-size:0.72rem;padding:0.2rem 0.5rem;border-radius:9999px;background:${c}18;color:${c};border:1px solid ${c}30;">${w}</span>`;
  });
  html+=`</div></div>`;

  // Step 3: Frequency table with bars
  html+=`<div class="card"><h3>빈도수 벡터</h3>`;
  html+=`<div style="overflow-x:auto;"><table style="border-collapse:collapse;width:100%;margin-top:0.5rem;">`;
  // Header
  html+=`<tr><td style="padding:0.4rem 0.6rem;font-family:var(--mono);font-size:0.62rem;color:var(--muted);border-bottom:2px solid var(--border);"></td>`;
  vocab.forEach((w,i)=>{
    const c=colors[i%colors.length];
    html+=`<td style="padding:0.4rem 0.3rem;text-align:center;font-family:var(--mono);font-size:0.6rem;color:${c};border-bottom:2px solid var(--border);min-width:2.5rem;">${w}</td>`;
  });
  html+=`</tr>`;
  // Rows
  results.forEach((r,si)=>{
    html+=`<tr>`;
    html+=`<td style="padding:0.5rem 0.6rem;font-size:0.78rem;border-bottom:1px solid var(--border);white-space:nowrap;">문장 ${si+1}</td>`;
    vocab.forEach((w,i)=>{
      const v=r.freq[w];
      const c=colors[i%colors.length];
      html+=`<td style="padding:0.3rem;text-align:center;border-bottom:1px solid var(--border);">`;
      if(v>0){
        html+=`<div style="display:inline-flex;align-items:center;justify-content:center;width:1.6rem;height:1.6rem;border-radius:50%;background:${c}22;color:${c};font-family:var(--mono);font-size:0.82rem;font-weight:700;">${v}</div>`;
      }else{
        html+=`<span style="font-family:var(--mono);font-size:0.78rem;color:var(--border);">0</span>`;
      }
      html+=`</td>`;
    });
    html+=`</tr>`;
  });
  html+=`</table></div></div>`;

  // Vector representation
  html+=`<div class="card"><h3>벡터 표현</h3>`;
  results.forEach((r,si)=>{
    const vec=vocab.map(w=>r.freq[w]);
    html+=`<p style="font-family:var(--mono);font-size:0.78rem;margin:0.3rem 0;"><span style="color:var(--muted);">문장 ${si+1} =</span> <span style="font-weight:600;">[${vec.join(', ')}]</span></p>`;
  });
  html+=`</div>`;

  box.innerHTML=html;
}

function bowAnalyze(){
  const text=document.getElementById('bow-input').value;
  const sentences=text.split('\n').map(s=>s.trim()).filter(s=>s.length>0);
  if(sentences.length===0)return;
  const data=bowProcess(sentences);
  bowRenderResult(data);
}

// Animated version
let bowAnimIv=null;
function bowAnimate(){
  if(bowAnimIv){clearInterval(bowAnimIv);bowAnimIv=null;}
  const text=document.getElementById('bow-input').value;
  const sentences=text.split('\n').map(s=>s.trim()).filter(s=>s.length>0);
  if(sentences.length===0)return;
  const data=bowProcess(sentences);
  const {results,vocab}=data;
  const box=document.getElementById('bow-result');
  const colors=['#b44133','#4a6b8a','#5a7a5a','#8a6a4a','#6a4a8a','#4a8a7a','#8a4a6a','#7a8a4a'];

  // Animation steps:
  // 0: show original sentences
  // 1..N: show stopword removal per sentence
  // N+1: show vocabulary
  // N+2: show frequency counting animated
  const steps=[];
  steps.push('sentences');
  results.forEach((_,i)=>steps.push('stop_'+i));
  steps.push('vocab');
  steps.push('freq');

  let si=0;
  function renderStep(){
    const step=steps[si];
    let html='';

    // Always show completed previous steps
    if(si>=1){
      // Show sentences header
      html+=`<div class="card"><h3>입력 문장</h3>`;
      results.forEach((r,i)=>{html+=`<p style="font-size:0.84rem;margin:0.2rem 0;">${r.original}</p>`;});
      html+=`</div>`;
    }

    // Stopword removal steps
    for(let i=0;i<results.length;i++){
      const stepKey='stop_'+i;
      const idx=steps.indexOf(stepKey);
      if(si>=idx){
        const r=results[i];
        html+=`<div class="card" style="${si===idx?'outline:2px solid var(--fg);outline-offset:-2px;':''}">`
        html+=`<h3>문장 ${i+1}: 단어 분리</h3>`;
        html+=`<div style="display:flex;flex-wrap:wrap;gap:0.3rem;">`;
        r.words.forEach(w=>{
          html+=`<span style="display:inline-block;padding:0.2rem 0.45rem;border-radius:var(--radius);font-family:var(--mono);font-size:0.78rem;background:var(--fg);color:var(--bg);font-weight:500;">${w}</span>`;
        });
        html+=`</div></div>`;
      }
    }

    // Vocabulary
    if(si>=steps.indexOf('vocab')){
      html+=`<div class="card" style="${step==='vocab'?'outline:2px solid var(--fg);outline-offset:-2px;':''}"><h3>단어 집합</h3>`;
      html+=`<div style="display:flex;flex-wrap:wrap;gap:0.3rem;">`;
      vocab.forEach((w,i)=>{
        const c=colors[i%colors.length];
        html+=`<span style="font-family:var(--mono);font-size:0.72rem;padding:0.2rem 0.5rem;border-radius:9999px;background:${c}18;color:${c};border:1px solid ${c}30;">${w}</span>`;
      });
      html+=`</div></div>`;
    }

    // Frequency
    if(si>=steps.indexOf('freq')){
      bowRenderFreqTable(html,results,vocab,colors,box);
      return;
    }

    if(step==='sentences'){
      html=`<div class="card" style="outline:2px solid var(--fg);outline-offset:-2px;"><h3>입력 문장</h3>`;
      results.forEach((r,i)=>{html+=`<p style="font-size:0.84rem;margin:0.2rem 0;">${r.original}</p>`;});
      html+=`</div>`;
    }

    box.innerHTML=html;
    si++;
    if(si<steps.length){
      bowAnimIv=setTimeout(renderStep,1200);
    }
  }
  renderStep();
}

function bowRenderFreqTable(prefix,results,vocab,colors,box){
  let html=prefix;
  html+=`<div class="card" style="outline:2px solid var(--fg);outline-offset:-2px;"><h3>빈도수 벡터</h3>`;
  html+=`<div style="overflow-x:auto;"><table style="border-collapse:collapse;width:100%;margin-top:0.5rem;">`;
  html+=`<tr><td style="padding:0.4rem 0.6rem;font-family:var(--mono);font-size:0.62rem;color:var(--muted);border-bottom:2px solid var(--border);"></td>`;
  vocab.forEach((w,i)=>{
    const c=colors[i%colors.length];
    html+=`<td style="padding:0.4rem 0.3rem;text-align:center;font-family:var(--mono);font-size:0.6rem;color:${c};border-bottom:2px solid var(--border);min-width:2.5rem;">${w}</td>`;
  });
  html+=`</tr>`;
  results.forEach((r,si)=>{
    html+=`<tr><td style="padding:0.5rem 0.6rem;font-size:0.78rem;border-bottom:1px solid var(--border);white-space:nowrap;">문장 ${si+1}</td>`;
    vocab.forEach((w,i)=>{
      const v=r.freq[w];
      const c=colors[i%colors.length];
      html+=`<td style="padding:0.3rem;text-align:center;border-bottom:1px solid var(--border);">`;
      if(v>0){
        html+=`<div style="display:inline-flex;align-items:center;justify-content:center;width:1.6rem;height:1.6rem;border-radius:50%;background:${c}22;color:${c};font-family:var(--mono);font-size:0.82rem;font-weight:700;">${v}</div>`;
      }else{
        html+=`<span style="font-family:var(--mono);font-size:0.78rem;color:var(--border);">0</span>`;
      }
      html+=`</td>`;
    });
    html+=`</tr>`;
  });
  html+=`</table></div></div>`;
  results.forEach((r,si)=>{
    const vec=vocab.map(w=>r.freq[w]);
    if(si===0) html+=`<div class="card"><h3>벡터 표현</h3>`;
    html+=`<p style="font-family:var(--mono);font-size:0.78rem;margin:0.3rem 0;"><span style="color:var(--muted);">문장 ${si+1} =</span> <span style="font-weight:600;">[${vec.join(', ')}]</span></p>`;
    if(si===results.length-1) html+=`</div>`;
  });
  box.innerHTML=html;
}

// ═══════════════════════════════════════════
//  NORMALIZATION
// ═══════════════════════════════════════════
document.getElementById('nsl').addEventListener('input',function(){
  const v=parseInt(this.value);
  document.getElementById('ni').textContent=v;
  document.getElementById('nf').textContent=(v/255).toFixed(3);
  document.getElementById('nsw').style.background=`rgb(${v},${v},${v})`;
});

// ═══════════════════════════════════════════
//  OBJECT DETECTION (COCO-SSD via TF.js)
// ═══════════════════════════════════════════
let detModel=null,detLoading=false;

function loadDetScripts(){
  return new Promise((resolve,reject)=>{
    if(window.cocoSsd){resolve();return;}
    const s1=document.createElement('script');
    s1.src='https://cdn.jsdelivr.net/npm/@tensorflow/tfjs';
    s1.onload=()=>{
      const s2=document.createElement('script');
      s2.src='https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd';
      s2.onload=()=>resolve();
      s2.onerror=()=>reject(new Error('COCO-SSD 로드 실패'));
      document.head.appendChild(s2);
    };
    s1.onerror=()=>reject(new Error('TensorFlow.js 로드 실패'));
    document.head.appendChild(s1);
  });
}

async function initDetModel(){
  if(detModel)return detModel;
  if(detLoading)return null;
  detLoading=true;
  const st=document.getElementById('det-status');
  st.textContent='모델 로딩 중... (처음 실행 시 수 초 소요)';
  try{
    await loadDetScripts();
    detModel=await cocoSsd.load();
    st.textContent='모델 준비 완료.';
    detLoading=false;
    return detModel;
  }catch(err){
    st.textContent='모델 로딩 실패: '+err.message;
    detLoading=false;
    return null;
  }
}

const COCO_KR={'person':'사람','bicycle':'자전거','car':'자동차','motorcycle':'오토바이','airplane':'비행기','bus':'버스','train':'기차','truck':'트럭','boat':'보트','traffic light':'신호등','fire hydrant':'소화전','stop sign':'정지 표지판','parking meter':'주차 미터기','bench':'벤치','bird':'새','cat':'고양이','dog':'개','horse':'말','sheep':'양','cow':'소','elephant':'코끼리','bear':'곰','zebra':'얼룩말','giraffe':'기린','backpack':'배낭','umbrella':'우산','handbag':'핸드백','tie':'넥타이','suitcase':'여행가방','frisbee':'프리스비','skis':'스키','snowboard':'스노보드','sports ball':'공','kite':'연','baseball bat':'야구 배트','baseball glove':'야구 글러브','skateboard':'스케이트보드','surfboard':'서프보드','tennis racket':'테니스 라켓','bottle':'병','wine glass':'와인잔','cup':'컵','fork':'포크','knife':'칼','spoon':'숟가락','bowl':'그릇','banana':'바나나','apple':'사과','sandwich':'샌드위치','orange':'오렌지','broccoli':'브로콜리','carrot':'당근','hot dog':'핫도그','pizza':'피자','donut':'도넛','cake':'케이크','chair':'의자','couch':'소파','potted plant':'화분','bed':'침대','dining table':'식탁','toilet':'변기','tv':'TV','laptop':'노트북','mouse':'마우스','remote':'리모컨','keyboard':'키보드','cell phone':'휴대폰','microwave':'전자레인지','oven':'오븐','toaster':'토스터','sink':'싱크대','refrigerator':'냉장고','book':'책','clock':'시계','vase':'꽃병','scissors':'가위','teddy bear':'곰 인형','hair drier':'드라이어','toothbrush':'칫솔'};

async function detRun(imgEl){
  const model=await initDetModel();
  if(!model)return;
  const st=document.getElementById('det-status');
  st.textContent='탐지 중...';

  const predictions=await model.detect(imgEl);

  // Draw on canvas
  const cv=document.getElementById('det-canvas');
  const ctx=cv.getContext('2d');
  cv.width=imgEl.naturalWidth||imgEl.width;
  cv.height=imgEl.naturalHeight||imgEl.height;
  ctx.drawImage(imgEl,0,0,cv.width,cv.height);

  const colors=['#b44133','#4a6b8a','#5a7a5a','#8a6a4a','#6a4a8a','#4a8a7a','#8a4a6a','#7a8a4a'];

  predictions.forEach((p,i)=>{
    const [x,y,w,h]=p.bbox;
    const c=colors[i%colors.length];
    ctx.strokeStyle=c;
    ctx.lineWidth=Math.max(2,Math.round(cv.width/200));
    ctx.strokeRect(x,y,w,h);

    const label=`${COCO_KR[p.class]||p.class} ${(p.score*100).toFixed(1)}%`;
    ctx.font=`bold ${Math.max(12,Math.round(cv.width/40))}px "Noto Sans KR", sans-serif`;
    const tm=ctx.measureText(label);
    const lh=Math.max(16,Math.round(cv.width/30));
    ctx.fillStyle=c;
    ctx.fillRect(x,y-lh-4,tm.width+10,lh+4);
    ctx.fillStyle='#fff';
    ctx.fillText(label,x+5,y-6);
  });

  document.getElementById('det-result').style.display='block';

  // List
  const list=document.getElementById('det-list');
  if(predictions.length===0){
    list.innerHTML='<p style="font-size:0.84rem;color:var(--muted);">탐지된 객체가 없습니다.</p>';
    st.textContent='탐지 완료 — 인식된 객체 없음';
  }else{
    let html='<div style="display:flex;flex-wrap:wrap;gap:0.4rem;">';
    predictions.forEach((p,i)=>{
      const c=colors[i%colors.length];
      const kr=COCO_KR[p.class]||p.class;
      html+=`<span style="display:inline-flex;align-items:center;gap:0.3rem;padding:0.3rem 0.6rem;border-radius:9999px;background:${c}18;color:${c};font-family:var(--mono);font-size:0.75rem;font-weight:600;border:1px solid ${c}30;">${kr} <span style="font-weight:400;opacity:0.7;">${(p.score*100).toFixed(1)}%</span></span>`;
    });
    html+='</div>';
    list.innerHTML=html;
    st.textContent=`탐지 완료 — ${predictions.length}개 객체 인식`;
  }
}

// Upload handlers
(()=>{
  const uz=document.getElementById('det-upz');
  const fi=document.getElementById('det-fup');
  if(!uz||!fi)return;
  uz.onclick=()=>fi.click();
  fi.onchange=e=>{if(e.target.files[0])detLoadImg(e.target.files[0]);};
  uz.ondragover=e=>{e.preventDefault();uz.classList.add('dg');};
  uz.ondragleave=()=>uz.classList.remove('dg');
  uz.ondrop=e=>{e.preventDefault();uz.classList.remove('dg');if(e.dataTransfer.files[0])detLoadImg(e.dataTransfer.files[0]);};
})();

function detLoadImg(file){
  const reader=new FileReader();
  reader.onload=e=>{
    const img=new Image();
    img.onload=()=>detRun(img);
    img.src=e.target.result;
  };
  reader.readAsDataURL(file);
}

// Service Worker
if('serviceWorker' in navigator)try{navigator.serviceWorker.register('sw.js');}catch(e){}

// Credits
console.log('%c AI 수학 ','background:#1a1714;color:#f5f0ea;font-size:14px;font-weight:bold;padding:4px 8px;border-radius:4px;');
console.log('%c제작: gmb9817','font-size:12px;color:#1a1714;');
console.log('%c도움을 준 사람들: nflight11, frozenca, wizardrabbit, cubic','font-size:11px;color:#78726a;');
</script>
</body>
</html>
