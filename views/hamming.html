<div class="view" id="v-hamming">
  <p class="mono" style="margin-bottom:0.4rem;">해밍 거리</p>
  <h2>XOR 연산과 유사도 측정</h2>
  <p class="desc">
    같은 길이의 두 이진 문자열에서 대응하는 위치의 값이 서로 다른 개수를 해밍 거리라 합니다.
    XOR 연산 결과에서 1의 개수를 세면 됩니다.
  </p>

  <div class="card">
    <h3>왜 해밍 거리를 배울까?</h3>
    <p>컴퓨터는 이미지, 텍스트, 소리 등 모든 데이터를 0과 1로 저장합니다.
      두 데이터가 얼마나 비슷한지를 판단하려면, 같은 위치에서 값이 다른 개수를 세면 됩니다.
      이것이 해밍 거리의 핵심 아이디어이며, 데이터 분류의 가장 기본적인 수학적 도구입니다.</p>
    <p style="margin-top:0.5rem;">해밍 거리는 통신 분야에서 오류 검출 및 정정에 사용되며,
      생물정보학에서 DNA 서열 비교, 정보 검색에서 유사 문서 탐색,
      그리고 QR 코드의 오류 복원 등 다양한 분야에서 활용됩니다.</p>
  </div>

    <div class="tabs">
    <button class="tab on" onclick="htab(0,this)">탐구 게임</button>
    <button class="tab" onclick="htab(1,this)">XOR 원리</button>
    <button class="tab" onclick="htab(2,this)">비트맵 실습</button>
  </div>

  <!-- TAB 0: GAME -->
<div class="tpanel on" id="ht0">
    <div class="status" id="hdg-progBox" style="margin-bottom:1rem;">탐구 진행도: <span id="hdg-progTxt">1</span> / 9</div>

<style>
      #v-hamming #ht0 .hdg-stage { display:none; overflow:hidden; border:1px solid var(--border); border-radius:var(--radius); background:var(--card); }
      #v-hamming #ht0 .hdg-stage.on { display:block; animation: hdgFade 0.25s ease; }
      #v-hamming #ht0 .hdg-res { display:none; }
      #v-hamming #ht0 .hdg-res.on { display:block; animation: hdgFade 0.25s ease; }
      @keyframes hdgFade { from { opacity:0; transform: translateY(6px);} to { opacity:1; transform: translateY(0);} }

      #v-hamming #ht0 .hdg-shead { background:var(--card-h); color:var(--fg); padding:0.9rem 1rem; font-weight:700; border-bottom:1px solid var(--border); }
      #v-hamming #ht0 .hdg-sbody { padding:1rem; }

      #v-hamming #ht0 .hdg-desc { color:var(--fg); line-height:1.6; margin-bottom:0.9rem; word-break: keep-all; }

      #v-hamming #ht0 .hdg-wrap { display:flex; justify-content:center; align-items:center; gap:0.9rem; margin-bottom:0.9rem; flex-wrap:wrap; }
      #v-hamming #ht0 .hdg-grid {
        display:grid; gap:3px; background:var(--border); padding:5px; border-radius:6px; width:max-content; margin:0 auto;
      }
      #v-hamming #ht0 .hdg-g3 { grid-template-columns: repeat(3, 2.2rem); grid-template-rows: repeat(3, 2.2rem); }
      #v-hamming #ht0 .hdg-g4 { grid-template-columns: repeat(4, 1.75rem); grid-template-rows: repeat(4, 1.75rem); }

      #v-hamming #ht0 .hdg-cell{
        background:var(--bg);
        display:flex; align-items:center; justify-content:center;
        font-family:var(--mono); font-size:0.85rem; font-weight:700;
        border:1px solid var(--border); border-radius:4px;
        user-select:none;
      }
      #v-hamming #ht0 .hdg-cell.on { background:var(--fg); color:var(--bg); }
      #v-hamming #ht0 .hdg-interactive .hdg-cell{ cursor:pointer; background:var(--bg); }
      #v-hamming #ht0 .hdg-interactive .hdg-cell:hover{ filter: brightness(0.97); }
      #v-hamming #ht0 .hdg-interactive .hdg-cell.on{ background:var(--red); color:#fff; border-color: var(--red); }

      #v-hamming #ht0 .hdg-opt{
        display:block; width:100%;
        padding:0.75rem 0.9rem; margin:0.5rem 0;
        background:var(--bg);
        border:1px solid var(--border);
        border-radius:var(--radius);
        cursor:pointer;
        text-align:left;
        transition: all 0.15s;
        font-family: var(--sans);
        color: var(--fg);
      }
      #v-hamming #ht0 .hdg-opt:hover{ background:var(--card-h); border-color:var(--accent); }
      #v-hamming #ht0 .hdg-act { margin-top:0.5rem; }

      #v-hamming #ht0 .hdg-in{
        width:8rem; padding:0.55rem 0.65rem;
        border-radius:var(--radius);
        border:1.5px solid var(--border);
        font-family: var(--mono);
        font-weight:700;
        background:var(--bg);
        color:var(--fg);
        text-align:center;
      }

      #v-hamming #ht0 canvas{ background:var(--bg); border-radius:var(--radius); cursor:pointer; border:1px solid var(--border); display:block; margin:0.6rem auto; }

      #v-hamming #ht0 .hdg-fb{ display:none; margin-top:0.9rem; padding:0.9rem; border-radius:var(--radius); line-height:1.6; }
      #v-hamming #ht0 .hdg-fb.succ{ display:block; background: rgba(90,122,90,0.12); border:1px solid rgba(90,122,90,0.35); color: var(--fg); }
      #v-hamming #ht0 .hdg-fb.err{ display:block; background: rgba(180,65,51,0.10); border:1px solid rgba(180,65,51,0.28); color: var(--fg); }

      #v-hamming #ht0 .hdg-score { background:var(--card-h); padding:1rem; border-radius:var(--radius); text-align:center; border:1px solid var(--border); }
      #v-hamming #ht0 .hdg-score .big { font-family:var(--mono); font-size:1.6rem; font-weight:800; }
      #v-hamming #ht0 .hdg-wrong { background:var(--bg); border:1px solid rgba(180,65,51,0.35); border-left:4px solid var(--red); padding:0.75rem; margin:0.6rem 0; border-radius:var(--radius); }
      #v-hamming #ht0 .hdg-vec { background:var(--bg); padding:0.8rem; border-radius:var(--radius); border:1px solid var(--border); font-family:var(--mono); letter-spacing:1px; text-align:center; }
      #v-hamming #ht0 .hdg-nav { display:flex; gap:0.6rem; margin-top:1rem; }
      #v-hamming #ht0 .hdg-nav .btn{ flex:1; }
    </style>

    <div id="hdg-root">
      <div class="hdg-stage on" id="hdg-st1">
        <div class="hdg-shead">탐구 1. 이미지 행렬의 차이점 검출</div>
        <div class="hdg-sbody">
          <div class="hdg-desc">
            인공지능은 이미지를 0(흰색)과 1(색칠됨)의 행렬로 인식합니다.<br>
            행렬 A와 B를 비교하여, <b>숫자가 서로 다른 위치</b>를 찾아 결과 행렬을 클릭해 1로 만드세요.
          </div>
          <div class="hdg-wrap">
            <div style="text-align:center;">
              <span style="font-size:0.78rem;font-weight:700;color:var(--muted);">행렬 A</span>
              <div class="hdg-grid hdg-g3" id="hdg-g1_org"></div>
            </div>
            <span style="font-family:var(--mono);color:var(--muted);font-size:1.1rem;">⊕</span>
            <div style="text-align:center;">
              <span style="font-size:0.78rem;font-weight:700;color:var(--muted);">행렬 B</span>
              <div class="hdg-grid hdg-g3" id="hdg-g1_cor"></div>
            </div>
            <span style="font-family:var(--mono);color:var(--muted);font-size:1.1rem;">=</span>
            <div style="text-align:center;">
              <span style="font-size:0.78rem;font-weight:800;color:var(--red);">결과 행렬</span>
              <div class="hdg-grid hdg-g3 hdg-interactive" id="hdg-g1_ans"></div>
            </div>
          </div>
          <button class="btn pri hdg-act" onclick="hdg_chk1()">결과 확인</button>
          <div id="hdg-fb1" class="hdg-fb"></div>
        </div>
      </div>

      <div class="hdg-stage" id="hdg-st2">
        <div class="hdg-shead">탐구 2. 배타적 논리합(XOR)의 정의</div>
        <div class="hdg-sbody">
          <div class="hdg-desc">
            위에서 사용한 기호 <b>⊕</b>는 <b>배타적 논리합(XOR)</b>입니다. 연산 결과가 <b>1(참)</b>이 되는 올바른 조건은?
          </div>
          <button class="hdg-opt" onclick="hdg_chk2(1,false,this)">① 1 ⊕ 1 (두 값이 모두 1일 때)</button>
          <button class="hdg-opt" onclick="hdg_chk2(2,false,this)">② 0 ⊕ 0 (두 값이 모두 0일 때)</button>
          <button class="hdg-opt" onclick="hdg_chk2(3,true,this)">③ 1 ⊕ 0 (두 값이 서로 다를 때)</button>
          <div id="hdg-fb2" class="hdg-fb"></div>
        </div>
      </div>

      <div class="hdg-stage" id="hdg-st3">
        <div class="hdg-shead">탐구 3. 집합 영역 시각화</div>
        <div class="hdg-sbody">
          <div class="hdg-desc">
            XOR 규칙을 집합에 적용합니다. 벤 다이어그램을 터치하여 <b>두 집합 A와 B가 서로 다른 값을 가질 때(한쪽에만 원소가 존재할 때)</b>의 영역을 색칠하세요.
          </div>
          <canvas id="hdg-vCanvas" width="350" height="200"></canvas>
          <div class="btn-row" style="justify-content:center;margin-top:0.6rem;"><button class="btn pri" onclick="hdg_chk3()">정답 확인</button></div>
          <div id="hdg-fb3" class="hdg-fb"></div>
        </div>
      </div>

      <div class="hdg-stage" id="hdg-st4">
        <div class="hdg-shead">탐구 4. 대칭차집합의 수식 표현</div>
        <div class="hdg-sbody">
          <div class="hdg-desc">
            탐구 3의 영역은 <b>대칭차집합</b>입니다. 위 영역을 표현하는 수식으로 <b>옳지 않은 것</b>은?
          </div>
          <button class="hdg-opt" onclick="hdg_chk4(1,false,this)">① (A ∪ B) − (A ∩ B)</button>
          <button class="hdg-opt" onclick="hdg_chk4(2,false,this)">② (A − B) ∪ (B − A)</button>
          <button class="hdg-opt" onclick="hdg_chk4(3,true,this)">③ (A ∩ B) ∪ (A − B)</button>
          <div id="hdg-fb4" class="hdg-fb"></div>
        </div>
      </div>

      <div class="hdg-stage" id="hdg-st5">
        <div class="hdg-shead">탐구 5. 1차원 벡터의 XOR 연산</div>
        <div class="hdg-sbody">
          <div class="hdg-desc">
            이미지를 1차원 벡터로 변환한 A와 B의 성분별 ⊕ 연산 결과를 띄어쓰기 없이 입력하세요.
          </div>
          <div class="hdg-vec">A = (1, 0, 1, 1, 0)<br>B = (1, 1, 0, 1, 0)</div>
          <div style="display:flex;gap:0.6rem;justify-content:center;align-items:center;flex-wrap:wrap;margin-top:0.6rem;">
            <span style="font-family:var(--mono);font-weight:700;">A ⊕ B =</span>
            <input type="text" id="hdg-i5" class="hdg-in" placeholder="예: 01010" maxlength="20">
            <button class="btn pri" onclick="hdg_chk5()">결과 확인</button>
          </div>
          <div id="hdg-fb5" class="hdg-fb"></div>
        </div>
      </div>

      <div class="hdg-stage" id="hdg-st6">
        <div class="hdg-shead">탐구 6. 해밍 거리(Hamming Distance)</div>
        <div class="hdg-sbody">
          <div class="hdg-desc">
            탐구 5에서 구한 결과 벡터에서 <b>1의 개수</b>를 두 데이터 사이의 <b>해밍 거리</b>라고 합니다. 앞서 계산한 벡터 사이의 해밍 거리는 얼마입니까?
          </div>
          <div style="display:flex;gap:0.6rem;justify-content:center;align-items:center;flex-wrap:wrap;">
            <span style="font-family:var(--mono);font-weight:700;">거리 d =</span>
            <input type="number" id="hdg-i6" class="hdg-in" style="width:5rem;">
            <button class="btn pri" onclick="hdg_chk6()">확인</button>
          </div>
          <div id="hdg-fb6" class="hdg-fb"></div>
        </div>
      </div>

      <div class="hdg-stage" id="hdg-st7">
        <div class="hdg-shead">탐구 7. 마스크 행렬 역추산</div>
        <div class="hdg-sbody">
          <div class="hdg-desc">
            원본 행렬 P에 마스크 행렬 X를 XOR 연산하여 손상된 행렬 Q가 되었습니다. (P ⊕ X = Q). 역연산을 추론하여 마스크 X의 성분을 찾아 색칠하세요.
          </div>
          <div class="hdg-wrap">
            <div style="text-align:center;">
              <span style="font-size:0.78rem;font-weight:700;color:var(--muted);">원본 P</span>
              <div class="hdg-grid hdg-g3" id="hdg-g7_org"></div>
            </div>
            <span style="font-family:var(--mono);color:var(--muted);font-size:1.1rem;">⊕</span>
            <div style="text-align:center;">
              <span style="font-size:0.78rem;font-weight:800;color:var(--red);">마스크 X</span>
              <div class="hdg-grid hdg-g3 hdg-interactive" id="hdg-g7_ans"></div>
            </div>
            <span style="font-family:var(--mono);color:var(--muted);font-size:1.1rem;">=</span>
            <div style="text-align:center;">
              <span style="font-size:0.78rem;font-weight:700;color:var(--muted);">손상 Q</span>
              <div class="hdg-grid hdg-g3" id="hdg-g7_cor"></div>
            </div>
          </div>
          <button class="btn pri hdg-act" onclick="hdg_chk7()">결과 확인</button>
          <div id="hdg-fb7" class="hdg-fb"></div>
        </div>
      </div>

      <div class="hdg-stage" id="hdg-st8">
        <div class="hdg-shead">탐구 8. 4×4 행렬의 이미지 분류</div>
        <div class="hdg-sbody">
          <div class="hdg-desc">
            인공지능은 <b>해밍 거리가 가장 짧은(차이가 적은) 데이터</b>로 이미지를 분류합니다. 입력 행렬 T와 가장 해밍 거리가 짧은 표본을 고르세요.
          </div>
          <div class="hdg-wrap" style="align-items:flex-start;">
            <div style="text-align:center;border:1px dashed var(--blue);padding:0.7rem;border-radius:var(--radius);">
              <span style="font-size:0.8rem;font-weight:800;color:var(--blue);">입력 행렬 T</span>
              <div class="hdg-grid hdg-g4" id="hdg-g8_t" style="margin-top:0.35rem;"></div>
            </div>
            <div style="text-align:center;">
              <span style="font-size:0.8rem;font-weight:800;">표본 S1</span>
              <div class="hdg-grid hdg-g4" id="hdg-g8_s1" style="margin-top:0.35rem;"></div>
              <button class="hdg-opt" style="text-align:center;margin-top:0.6rem;" onclick="hdg_chk8(1,false,this)">선택</button>
            </div>
            <div style="text-align:center;">
              <span style="font-size:0.8rem;font-weight:800;">표본 S2</span>
              <div class="hdg-grid hdg-g4" id="hdg-g8_s2" style="margin-top:0.35rem;"></div>
              <button class="hdg-opt" style="text-align:center;margin-top:0.6rem;" onclick="hdg_chk8(2,true,this)">선택</button>
            </div>
          </div>
          <div id="hdg-fb8" class="hdg-fb"></div>
        </div>
      </div>

      <div class="hdg-stage" id="hdg-st9">
        <div class="hdg-shead">탐구 9. 단원 확장: 이미지 이진화(Binarization)</div>
        <div class="hdg-sbody">
          <div class="hdg-desc">
            XOR 연산 전, 인공지능은 0~255 명도 값을 0과 1로 단순화하는 <b>이진화</b>를 거칩니다.<br>
            <b>임계값(Threshold) 128</b>을 기준으로, <b>128 이상이면 1(클릭), 미만이면 0(빈칸)</b>이 되도록 변환해 보세요.
          </div>
          <div class="hdg-wrap">
            <div style="text-align:center;">
              <span style="font-size:0.78rem;font-weight:700;color:var(--muted);">명도 행렬</span>
              <div class="hdg-grid hdg-g3" id="hdg-g9_org"></div>
            </div>
            <span style="font-family:var(--mono);color:var(--muted);font-size:1.1rem;">➔</span>
            <div style="text-align:center;">
              <span style="font-size:0.78rem;font-weight:800;color:var(--red);">이진화 행렬</span>
              <div class="hdg-grid hdg-g3 hdg-interactive" id="hdg-g9_ans"></div>
            </div>
          </div>
          <button class="btn pri hdg-act" onclick="hdg_chk9()">결과 확인</button>
          <div id="hdg-fb9" class="hdg-fb"></div>
        </div>
      </div>

      <div class="hdg-res" id="hdg-stRes">
        <div class="hdg-shead" style="background:rgba(200,185,166,0.35);">최종 진단 결과 리포트</div>
        <div class="hdg-sbody">
          <div class="hdg-score">
            <div style="font-weight:700;">나의 최종 정답률</div>
            <div class="big"><span id="hdg-finScore">0</span> / 9</div>
            <div style="font-size:0.72rem;color:var(--muted);margin-top:0.35rem;">* 각 탐구를 최종적으로 정답 처리한 결과를 바탕으로 산출되었습니다.</div>
          </div>

          <h4 style="margin:1rem 0 0.4rem 0;">오답 노트 및 핵심 풀이</h4>
          <div id="hdg-wList"></div>
        </div>
      </div>

      <div class="btn-row hdg-nav">
        <button id="hdg-pBtn" class="btn" onclick="hdg_move(-1)" style="display:none;">이전 문제로</button>
        <button id="hdg-nBtn" class="btn pri" onclick="hdg_move(1)" style="display:none;">다음으로 진행</button>
      </div>
    </div>
  </div>


  <!-- TAB 1: XOR -->
<div class="tpanel" id="ht1">
    <div class="card">
      <h3>XOR 연산 진리표</h3>
      <p>두 비트가 서로 다를 때 1, 같을 때 0을 출력합니다.</p>
      <div class="math">0 ⊕ 0 = 0   (같음)
0 ⊕ 1 = 1   (다름)
1 ⊕ 0 = 1   (다름)
1 ⊕ 1 = 0   (같음)

해밍 거리 d(A,B) = Σ (Aᵢ ⊕ Bᵢ)</div>
    </div>

    <div class="card">
      <h3>직접 해보기 — 비트를 클릭하여 값을 바꿔보세요</h3>
      <p style="margin-bottom:0.8rem;">각 비트를 클릭하면 0과 1이 토글됩니다. XOR 결과와 해밍 거리가 실시간으로 계산됩니다.</p>
      <div id="hd-box" style="display:flex;flex-direction:column;gap:0.5rem;align-items:center;"></div>
      <div id="hd-res" class="status" style="text-align:center;font-size:0.85rem;font-weight:600;"></div>
    </div>

    <div class="info">
      <strong>대칭차집합과의 관계:</strong>
      XOR 연산은 대칭차집합 <span class="mi">(A∪B)−(A∩B)</span>과 동일한 결과를 보입니다.
      이 연산에 최소 2단계가 필요하므로, 다층 퍼셉트론에서 은닉층이 2개 이상 필요한 이유와 연결됩니다.
    </div>
  </div>

  <!-- TAB 2: BITMAP -->
  
  <!-- TAB 2: BITMAP -->
<div class="tpanel" id="ht2">
    <p class="desc" style="margin-bottom:1rem;">
      격자에 숫자를 직접 그려보세요. 클릭/드래그로 흑백을 토글합니다.
      참조 데이터(0~9)와의 해밍 거리를 계산하여 가장 유사한 숫자를 자동 분류합니다.
    </p>

    <div style="display:flex;gap:0.3rem;margin-bottom:1rem;flex-wrap:wrap;">
      <button class="btn bsz active" onclick="setSz(6,this)">6×6</button>
      <button class="btn bsz" onclick="setSz(8,this)">8×8</button>
      <button class="btn bsz" onclick="setSz(12,this)">12×12</button>
    </div>

    <div style="display:flex;gap:1.2rem;flex-wrap:wrap;align-items:flex-start;">
      <div style="min-width:14rem;">
        <p class="mat-label">내 그림</p>
        <div id="ubmp" class="bmp" aria-label="user bitmap"></div>

        <div class="btn-row" style="justify-content:flex-start;margin-top:0.8rem;flex-wrap:wrap;">
          <button class="btn" onclick="clrBmp()">지우기</button>
          <button class="btn pri" onclick="calcH()">해밍 거리 계산</button>
        </div>

        <div style="margin-top:1.1rem;">
          <p class="mat-label" style="margin-bottom:0.4rem;">참조 숫자 미리보기</p>
          <div id="rbtn" style="display:flex;gap:0.3rem;flex-wrap:wrap;margin-bottom:0.6rem;"></div>
          <div style="display:flex;gap:0.9rem;flex-wrap:wrap;align-items:flex-start;">
            <div style="flex:1;min-width:160px;">
              <div id="refpreview"></div>
            </div>
            <div style="flex:1;min-width:160px;">
              <div id="ovpreview"></div>
            </div>
          </div>
        </div>
      </div>

      <div style="flex:1;min-width:14rem;">
        <p class="mat-label">분류 결과</p>
        <div id="hbars"><p style="font-size:0.8rem;color:var(--muted);">숫자를 그린 후 계산 버튼을 누르세요.</p></div>
        <div id="hbest" class="status" style="font-weight:600;"></div>
        <div id="hoverlap" style="margin-top:1rem;"></div>
      </div>
    </div>
  </div>



  <div style="height:1px;background:var(--border);margin:1.6rem 0;"></div>

  <div class="card">
    <div style="display:flex;gap:1rem;align-items:flex-start;flex-wrap:wrap;">
      <img
        src="Mnist%20%EC%B0%B8%EA%B3%A0%20%EC%82%AC%EC%A7%842.png"
        onerror="this.onerror=null;this.src='Mnist%202.png';"
        alt="MNIST 예시 이미지"
        style="width:240px;max-width:44vw;border-radius:0.8rem;border:1px solid var(--border);background:#fff;display:block;"
      >
      <div style="flex:1;min-width:240px;">
        <h3 style="margin-top:0;">해밍 거리로 이미지를 학습할 때 어떠한 문제점이 있을까요?</h3>
        <p>손글씨 6개를 보면 사람은 0인지 아닌지 인지할수 있지만, 해밍거리를 활용하는 경우에는 위치 및 평행 이동, 확대 및 축소 등을 고려하지 못해 모든 숫자를 0으로 인식하는데는 한계가 있습니다. 이를 해결하기 위해 적용된 방식이 인공신경망을 기반으로 한 딥러닝입니다. 인공지능이 주어진 데이터를 스스로 학습하는 딥러닝 기술 중 다음 시간에는 합성곱 인공 신경망(Convoutional Nenural Network, CNN)을 알아보고자 합니다.</p>
      </div>
    </div>
  </div>
</div>
